#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Function Definitions
# 1. I decided to put my functions into a file .functions just to keep them
#    separate from my entire .bashrc file. This is because I like the idea
#    of being able to debug new things separately.
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# For checking licenses.
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function licenses {
    /project/hw/bin/lmstat -a -c /cad/flexlm/Synopsys.dir/license.dat | /bin/less
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Color settings for prompts.
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function Prompt_Settings {
    local GRAY="\[\033[1;30m\]"
    local LIGHT_GRAY="\[\033[0;37m\]"
    local CYAN="\[\033[0;36m\]"
    local LIGHT_CYAN="\[\033[1;36m\]"
    local NO_COLOUR="\[\033[0m\]"
    local BRIGHTGREEN="\[\033[1;32m\]"
}

function rename_fen { 
    local file=$@
    cp ${file} $(sha1sum ${file} | perl -ne 's/^(.{8}).*/$1/;print;').fen
}

function fen_name {
    local file=$@
    echo $(sha1sum ${file} | perl -ne 's/^(.{8}).*/$1/;print;').fen
}

function save_fen { 
    local file=$@
    cp -f ${file} $HOME/Downloads/CHESS/FenPuzzles/$(fen_name $file)
}

function paste_fen {
    local todir=$@
    if [ "${todir}" == "" ] ; then
        todir=$HOME/Downloads/CHESS/FenPuzzles/
    fi
    tmp=$(pbpaste | sha1sum ${file} | perl -ne 's/^(.{8}).*/$1/;print;')
    pbpaste > ${todir}/${tmp}.fen
}

function save_firmware {
    local file=$@
    cp ${file} ${file}.$(sha1sum ${file} | perl -ne 's/^(.{8}).*/$1/;print;')
}

function make_nice_filenames {
    local IFS=$(echo -ne "\n\r")
    for i in $@
    do
        j=$(echo $i | perl -ne 's/ /_/g;print;' )
        mv "$i" "$j"
    done
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Turns on and off the full path at the top of the title bar.
#
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function sprompt {
    TITLEBAR="\[\033]0;\u@\H: \w\007\]"
    export TITLEBAR

    if [ "$1" == "on" ]; then
        if [ -f $HOME/.prompt ] ; then
            export MY_PROMPT=$(cat $HOME/.prompt)
        else
            export MY_PROMPT=${SHORT_PROMPT}
        fi
    else
        if [ -f $HOME/.long_prompt ] ; then
            export MY_PROMPT=$(cat $HOME/.long_prompt)
        else
            export MY_PROMPT=${LONG_PROMPT}
        fi
    fi

    tty -s && export PS1=${MY_PROMPT}${TITLEBAR}
}


#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Turns on and off the full path at the top of the title bar.
#
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function stealth {
    TITLEBAR="\[\033]0;\u@\H: \w\007\]"
    export TITLEBAR
    if [ "$1" == "on" ]; then
        export MY_PROMPT=${STEALTH_PROMPT}
    else
        export MY_PROMPT=${SHORT_PROMPT}
    fi

    tty -s && export PS1=${MY_PROMPT}${TITLEBAR}
}


#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
#
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function lprompt {
    tty -s && export PS1=${MY_PROMPT}${TITLEBAR}
}


#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# I use this to display a specific title...
#
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function xtitle {
# Turn off the menu prompt
    tty -s && export PS1=${MY_PROMPT}   
    echo -e "\033]0;$@\007"
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Turning off the Xtitle
#
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function notitle {
    tty -s && export PS1=$MY_PROMPT
}


#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Function for looking up names
#
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function name {
    /usr/local/contrib/bin/phonebook $@
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# For Loading aliases...
#
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function ldalias {
    local alias_cmd
    local alias_name
    while read -r line; do
#            echo "Line is $line"
            `echo $line | grep -v "^ *#" >&1 > /dev/null`
            if [ $? ] ; then
                alias_name=`echo $line | perl -ne 's/(.*?)=.*/$1/; print;'`
                if [ ! -z "${alias_name}" ] ; then
                    alias_cmd=`echo $line | perl -ne 's/.*?=(.*)$/$1/; print;'`
                    if [ ! -z "${alias_cmd}" ] ; then
#                    echo "Evalueating"
#                    echo "alias ${alias_name}=${alias_cmd}"
                        echo "alias ${alias_name}=${alias_cmd}" >> ${HOME}/.bash_alias
                        eval "alias ${alias_name}=${alias_cmd} " >&1 > /dev/null
                    fi
                fi
            fi
    done < $1
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# function for switching on tcsh mode
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function cadence {
    exec /usr/local/bin/tcsh
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Alias for the dir command
#
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function dir {
    /bin/ls -alF  $1 | grep "^d"
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
#
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function _dirs {
#    /bin/ls -l | grep "^d" | perl -a -ne 'print "@F[8..$#F]\n"'
    local dir
    local filter="[^\.]"
    if [[ "$1" != ""  ]] && [ -d "$1" ]  ; then
#        echo "Using dir '$@'"
        dir=$1
        if [[ $# == 2 ]] ; then
#            echo "using custom filter"
            filter=$2
        fi
    else
        dir=.
#        filter="[^\.]"
    fi
#    echo "Using filter '${filter}'"
    ruby -e "print Dir.entries(\"${dir}\").find_all { 
            |i| File.directory?(\"${dir}/#{i}\") &&
                i =~ /^${filter}/
            }.map{ |i| 
               if \"${dir}\" == \"\"  || \"${dir}\" == \".\"
                  i
               else
                  File.expand_path(\"${dir}/#{i}\") 
               end

            }.join(\"\n\") + \"\n\""
 }

function dirs {
    local IFS=$(echo -ne "\n\r")
    if [ $# == 1 ] ; then
        \ls -d $(_dirs $1)
    else
        \ls -d $(_dirs . )
    fi
}


#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#  For debugging allocation of memory
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function dmalloc { 
eval `command /usr/bin//dmalloc $*` 
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Cleans up the PATH environmental variable
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function pclean {
    PATH=`${MY_CAD}/clean_path.pl $PATH $@`
    export PATH
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Turn on xtitle displays
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function xtitle_on {
    tty -s && export PS1="\h \W % \[\033]0;\u@\H: \w\007\]"
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Display information about each file and directory...
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function dir_stats {
        for i in `/bin/ls`; do du -sm $i ; done
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Displays all the colors of the rainbow...er,... of a Terminal
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function All_Colors {
 T='gYw'   # The test text
 echo -e "\n                 40m     41m     42m     43m\
      44m     45m     46m     47m";
    for FGs in '    m' '   1m' '  30m' '1;30m' '  31m' '1;31m' '  32m' \
            '1;32m' '  33m' '1;33m' '  34m' '1;34m' '  35m' '1;35m' \
                '  36m' '1;36m' '  37m' '1;37m';
    do FG=${FGs// /}
    echo -en " $FGs \033[$FG  $T  "
    for BG in 40m 41m 42m 43m 44m 45m 46m 47m;
        do echo -en "$EINS \033[$FG\033[$BG  $T  \033[0m";
    done
    echo;
    done
    echo
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Lists all of the files in a directory... useful for "for" loops
# 1. Make sure you egrep -v for the "total" string...or else you will
#    get 1 blank entry... which ain't so good.
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function files {
    /bin/ls -l | egrep -v "^d|total" | awk '{ print $9 }' | egrep -v "^ *$ "
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Lists all of the directories in reverse order...so that the most recent
# access is at the bottom
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function rdirs {
    local a=`dirs`
    local IFS=$(echo -ne "\n\r")
    ls -Gltdr --color=auto $(_dirs $1 $2)
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Lists all of the files in reverse order... so that the most recent
# access is at the bottom
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function rfiles {
    local files=`files`
    ll -ltr $files
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Not completed yet...
# My new LS function
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function cls {
    if [ -n `grep d ${1}` ] ; then
    # Know to use directory only
	ll | awk 'print {$9}'
    fi
    /bin/ls $1 -aF

}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Just prints out the week days for the next 10 weeks..
# Useful if you are writing up your weekly status...
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function weekdays {
    perl -MTime::Local -MDate::Manip -MTime::localtime -e '
    $tm = localtime();
    $sub = $tm->wday;
    for( $i = -$sub + 1; $i < 70; $i += 7 ) {
    $tm = localtime();
    $t = timelocal( @{$tm}[0..2], $i + $tm->mday, @{$tm}[4..5] );
    $d = ParseDate("epoch $t");
    $t = timelocal( @{$tm}[0..2], $i + $tm->mday + 4, @{$tm}[4..5] );
    $t1 = UnixDate( $d, "%m/%d/%Y");
    $d = ParseDate("epoch $t");
    $t2 = UnixDate( $d, "%m/%d/%Y");
    print "$t1 - $t2\n";
    }
    '
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Setting up spice environments
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function spice_env {
    export LM_LICENSE_FILE=/cad/flexlm/Avanti.dir/license.dat
    alias hspice='/cad/avanti/current/bin/hspice'
    alias awaves='/cad/avanti/current/bin/awaves'
}

function Unixtime {
        echo $@ | perl -MDate::Manip -e '
                $t = <>;
                chomp $t;
                $date = ParseDate( $t );
                if( $date eq "" ) {
                        print "Bad format\n";
                        exit;
                }
                print UnixDate( $date, "%s\n" ); 
        '
}       


#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# For loading
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function ldenv {
    unset my_paths
    for i in `cat $1`
    do
        my_paths=`echo $i | awk 'BEGIN {FS ="=" ; OFS=""}{ print "export ",$1,"=",$2}'`
        eval $my_paths
    done
}

#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# For reading in sourced csh files
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
function setenv {
    export $1=$2
}

function doit {
        ngspice -r out < $@
}

function open {
  if [[ $(uname -o) == "Cygwin" ]] ; then
	cygstart "$@"	
  else 
	gnome-open "$@"
  fi
}	 

function search {
  tracker-search "$@"
}
function mdfind {
  tracker-search "$@"
}


function mydo {
   flags=$@
   local IFS
   IFS="\n"
   for i in $@ ; do
      flags="$flags $i"
      echo "$i"
   done
}

function rm () {
  local path
  for path in "$@"; do
    # ignore any arguments
    if [[ "$path" = -* ]]; then :
    else
      local dst=${dst%%/*}
      dst=${dst##*/}
      # append the time if necessary
      if [ -e ~/.Trash/"${dst}" ]  ; then
          dst="${dst}_$(date +%Y-%m-%d_%H%M%S)"
      fi
      mv "$path" ~/.Trash/"$dst"
    fi
  done
}

function work() { 
    export DIARY_TYPE="work"
}
function personal() {
    export DIARY_TYPE="personal"
}
function aio() {
    export DIARY_TYPE="aio"
}

function __svn_ps1() {
    local s=
    if [[ -d ".svn" ]] ; then
        local r=`__svn_rev`
        local b=`__svn_branch`
        s=" ($b:$r)"
    fi
    echo -n "$s"
}

# Outputs the current trunk, branch, or tag
function __svn_branch() {
    local url=
    if [[ -d .svn ]]; then
        url=`svn info | awk '/URL:/ {print $2}'`
        if [[ $url =~ trunk ]]; then
            echo trunk
        elif [[ $url =~ /branches/ ]]; then
            echo $url | sed -e 's#^.*/\(branches/.*\)/.*$#\1#'
        elif [[ $url =~ /tags/ ]]; then
            echo $url | sed -e 's#^.*/\(tags/.*\)/.*$#\1#'
        fi
    fi
}

# Outputs the current revision
function __svn_rev() {
    local r=$(svn info | awk '/Revision:/ {print $2}')
    
    if [ ! -z $SVN_SHOWDIRTYSTATE ]; then
        local svnst flag
        svnst=$(svn status | grep '^\s*[?ACDMR?!]')
        [ -z "$svnst" ] && flag=*
        r=$r$flag
    fi
    echo $r
}

function vnc_paris () { 
    echo "Connecting to Paris at work"
    echo "You will have to use connection Paris@tunnel"
    ssh -A -L 5900:10.1.1.71:5900 69.199.148.22
}

function memcheck_gtest () {
    for i in $(get_gtests.pl $1 ) 
    do
        valgrind --error-exitcode=231 --tool=memcheck --leak-check=full --show-reachable=yes $1 --gtest_filter=$i 2>/dev/null > /dev/null
        if [[ $? != 0 ]] ; then 
            echo -ne "${RED}$i${RESET}\n"; 
        else 
            echo -ne "${GREEN}$i${RESET}\n"; 
        fi
    done
}
function memcheck_directory () {
    for i in *_test
    do
        valgrind --error-exitcode=231 --tool=memcheck --leak-check=full --show-reachable=yes $i 2>/dev/null > /dev/null
        if [[ $? != 0 ]] ; then 
            echo -ne "not ok # ${RED}$i${RESET}\n"; 
        else 
            echo -ne "ok     # ${GREEN}$i${RESET}\n"; 
        fi
    done
}
function gdb() {
    if [ ! -z GDB_SOURCE_DIRS ] ; then
        search_dirs=$(echo -ne $GDB_SOURCE_DIRS | perl -F: -ane 'print map {"-d $_ "} @F ')
    else
        search_dirs=""
    fi
    # echo "/usr/bin/gdb ${search_dirs} \"$@\""
    /usr/bin/gdb ${search_dirs} "$@"
}

function history_compress() {      
    cp $1 $1.bak;     
    keep=${USE_IXHASH};     
    export USE_IXHASH=1;     
    cat $1 | unique.pl | perl  -0400 -pne 's/#\d{10}\n(?=#\d{10}\n)/$1/gsm;' | sponge $1;     
    if [ "$keep" != "" ] ; then         
        export USE_IXHASH=${keep};     
    else         
        unset USE_IXHASH;     
    fi; 
}

function history_retouch() {      
    for i in ${HISTDIRECTORY}/bash_history_[0-9][0-9][0-9][0-9]_[0-9][0-9]_[0-9][0-9]_[0-9][0-9][0-9][0-9][0-9][0-9];      
    do          
        j=$(echo $i | perl -ne 's/^.*history_(\d{4})_(\d{2})_(\d{2})_(\d{2})(\d{2})(\d{2})/$1-$2-$3 $4:$5:$6/g;print;' );          
        touch -d "$j" $i;      
    done; 

    for i in ${HISTDIRECTORY}/bash_history_[0-9][0-9][0-9][0-9]_[0-9][0-9];
    do
        j=$(echo $i | perl -ne 's/^.*history_(\d{4})_(\d{2})/$1-$2-1/g;print;' );          
        touch -d "$j" $i;
    done
}

function show_cursor()  {
    printf "\033[?25h"
}
function hide_cursor() { 
    printf "\033[?25l"
}

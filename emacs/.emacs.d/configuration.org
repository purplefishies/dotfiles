#+TITLE: Emacs Configuration
#+AUTHOR: Jimi Damon
#+EMAIL: jdamon@gmail.com
#+OPTIONS: toc:nil num:nil


* Configure =use-package=

I use =use-package= to install and configure my packages. My =init.el= includes
the initial setup for =package.el= and ensures that =use-package= is installed,
since I wanna do that right away.

This makes sure that =use-package= will install the package if it's not already
available. It also means that I should be able to open Emacs for the first time
on a fresh Debian box and have my whole environment automatically installed. I'm
not /totally/ sure about that, but we're gettin' close.

#+BEGIN_SRC emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
  ;(setq load-prefer-newer nil)
#+END_SRC

Always compile packages, and use the newest version available.

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  ;(setq load-prefer-newer nil)
#+END_SRC

* Personal information
** Who am I? Where am I?

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Jimi Damon"
        user-mail-address "jdamon@gmail.com"
        calendar-latitude 32.7157
        calendar-longitude -117.1611
        calendar-location-name "San Diego, CA")
#+END_SRC

* Utility Functions

#+BEGIN_SRC emacs-lisp
  (defun jmd/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun jmd/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))

#+END_SRC

* General Appearance / Startup
** Font Type

#+BEGIN_SRC emacs-lisp
(set-default-font "Monaco-12")
#+END_SRC

** Display / Color

   Use inverted face
#+BEGIN_SRC emacs-lisp
      (if t 
         (if (display-graphic-p)
             (progn 
               (invert-face 'default)
               )
         )
      )
#+END_SRC

** Starting the Emacs Server
#+BEGIN_SRC emacs-lisp
(defvar server-socket-dir
  (let ((uid (user-uid)))
    (if (floatp uid)
        (format "/tmp/emacs%1.0f" uid)
      (format "/tmp/emacs%d" uid))))
(require 'server)
(server-ensure-safe-dir server-socket-dir)
(server-start) 

#+END_SRC 
** X11 and Headless
#+BEGIN_SRC emacs-lisp
  (unless window-system
    (when (getenv "DISPLAY")
      ;; Callback for when user cuts
      (defun xsel-cut-function (text &optional push)
        ;; Insert text to temp-buffer, and "send" content to xsel stdin
        (with-temp-buffer
          (insert text)
          ;; I prefer using the "clipboard" selection (the one the
          ;; typically is used by c-c/c-v) before the primary selection
          ;; (that uses mouse-select/middle-button-click)
          (call-process-region (point-min) (point-max) "xsel" nil 0 nil "--clipboard" "--input")))
      ;; Call back for when user pastes
      (defun xsel-paste-function()
        ;; Find out what is current selection by xsel. If it is different
        ;; from the top of the kill-ring (car kill-ring), then return
        ;; it. Else, nil is returned, so whatever is in the top of the
        ;; kill-ring will be used.
        (let ((xsel-output (shell-command-to-string "xsel --clipboard --output")))
          (unless (string= (car kill-ring) xsel-output)
            xsel-output )))
      ;; Attach callbacks to hooks
      (setq interprogram-cut-function 'xsel-cut-function)
      (setq interprogram-paste-function 'xsel-paste-function)
      ;; Idea from
      ;; http://shreevatsa.wordpress.com/2006/10/22/emacs-copypaste-and-x/
      ;; http://www.mail-archive.com/help-gnu-emacs@gnu.org/msg03577.html
      ))
#+END_SRC

** Clipboard
#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-primary t)
  (setq x-select-enable-clipboard t)
  ;; (setq interprogram-paste-function 'x-cut-buffer-or-selection-value)
#+END_SRC

** Key Bindings

#+BEGIN_SRC emacs-lisp

  (defun forward-word-correctly (&optional n)
    "Jump forward a word at a time"
    (interactive "P")
    (search-forward-regexp "[][[()_@#A-Za-z0-9&\\*\\\-\\.\\$]+")
                                          ; [A-Za-z0-9-]+"
    )

  (defun backward-word-correctly (&optional n)
    "Jump backward a word at a time"
    (interactive "P")
    (let (i)
      (search-backward-regexp "\\b[ ]+")
                                          ;    (search-backward-regexp "[A-Za-z0-9_=)]+")
                                          ;    (search-backward-regexp "[A-Za-z0-9_=\-\\)\\(]+")
      )
    )

  (global-set-key "\C-xg" 'goto-line)
  (global-set-key "\C-b" 'backward-kill-word)
  (global-set-key "\C-n" 'kill-word)
  (global-set-key "\C-f" 'backward-word)
  (global-set-key "\M-s" 'search-forward-regexp)
  (global-set-key "\C-g" 'forward-word-correctly)
                                          ; New binding to try out
  (global-set-key "\M-b" 'backward-sexp)
  (global-set-key "\M-n" 'forward-sexp)

  (global-set-key "\C-cc" 'comment-region)
  (global-set-key [(control left)]    'backward-word-correctly)
  (global-set-key [(control right)] 'forward-word-correctly)
#+END_SRC
** ANSI colors
#+BEGIN_SRC emacs-lisp
  (defun display-ansi-colors ()
    (interactive)
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region (point-min) (point-max))))
#+END_SRC
** Disabling electric parentheses
#+BEGIN_SRC emacs-lisp
  (electric-indent-mode -1)
  (add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))
#+END_SRC
** ROS Formatting

   Setting the formatting and give a bind key
#+BEGIN_SRC emacs-lisp
(defun run-ros-clang-format ()
  "Runs clang-format on cpp,h files in catkin_ws/ and reverts buffer."
  (interactive)
  (and
   (princ "HERE")
   (string-match "/catkin_ouster/.*\\.\\(h\\|cpp\\)$" buffer-file-name)
   (princ "THERE")
   (save-some-buffers 'no-confirm)
   (shell-command (concat "clang-format-3.8 -i -style=file " buffer-file-name))
   (princ "OTHER")
   (message (concat "Saved and ran clang-format on " buffer-file-name))
   (revert-buffer t t t)
))
(global-set-key [f8] 'run-ros-clang-format)
#+END_SRC
** Enable compilations with color

#+BEGIN_SRC emacs-lisp
(require 'ansi-color)
(defun colorize-compilation-buffer ()
  (toggle-read-only)
  (ansi-color-apply-on-region compilation-filter-start (point))
  (toggle-read-only))
(add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+END_SRC
** GDB exit upon receiving Quit
#+BEGIN_SRC emacs-lisp
(defvar all-gud-modes
  '(gud-mode comint-mode gdb-locals-mode gdb-frames-mode  gdb-breakpoints-mode)
  "A list of modes when using gdb")
(defun kill-all-gud-buffers ()
  "Kill all gud buffers including Debugger, Locals, Frames, Breakpoints.
Do this after `q` in Debugger buffer."
  (interactive)
  (save-excursion
        (let ((count 0))
          (dolist (buffer (buffer-list))
                (set-buffer buffer)
                (when (member major-mode all-gud-modes)
                  (setq count (1+ count))
                  (kill-buffer buffer)
                  (delete-other-windows))) ;; fix the remaining two windows issue
          (message "Killed %i buffer(s)." count))))
#+END_SRC

* Project management

I use a few packages in virtually every programming or writing environment to
manage the project, handle auto-completion, search for terms, and deal with
version control. That's all in here.

** =ag=

Set up =ag= for displaying search results.

#+BEGIN_SRC emacs-lisp
  (use-package ag)
#+END_SRC

** =company=

Use =company-mode= everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package company)
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

Use =M-/= for completion.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete-common)
#+END_SRC

** =dumb-jump=

The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it
doesn't require any additional setup. I've bound its most useful command to
=M-.=.

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :config
    (define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
    (setq dumb-jump-selector 'ivy))
#+END_SRC

** =flycheck=

 #+BEGIN_SRC emacs-lisp
   (use-package flycheck)
 #+END_SRC

** =magit=

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- Use =evil= keybindings with =magit=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- On the command line I'll generally push a new branch with a plain old =git
  push=, which automatically creates a tracking branch on (usually) =origin=.
  Magit, by default, wants me to manually specify an upstream branch. This binds
  =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
  -v=. Convenient!
- I'd like to start in the insert state when writing a commit message.

#+BEGIN_SRC emacs-lisp
  ;; (use-package magit
  ;;   :bind
  ;;   ("C-x g" . magit-status)

  ;;   :config
  ;;   (use-package evil-magit)
  ;;   (use-package with-editor)
  ;;   (setq magit-push-always-verify nil)
  ;;   (setq git-commit-summary-max-length 50)

  ;;   (with-eval-after-load 'magit-remote
  ;;     (magit-define-popup-action 'magit-push-popup ?P
  ;;       'magit-push-implicitly--desc
  ;;       'magit-push-implicitly ?p t))

  ;;   (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

I've been playing around with the newly-released =forge= for managing GitHub PRs
and issues. Seems slick so far.

#+BEGIN_SRC emacs-lisp
  ;; (use-package ghub)
  ;; (use-package forge)
#+END_SRC

** =projectile=

Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds it to the
easier-to-type =C-c v= to useful searches.

Bind =C-p= to fuzzy-finding files in the current project. We also need to
explicitly set that in a few other modes.

I use =ivy= as my completion system.

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projectile-defined project. I use the current directory as a
project root (if I'm not in a "real" project).

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :bind
    ("C-c v" . 'projectile-ag)

    :config
    (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion ag-mode-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)

    (setq projectile-completion-system 'ivy)
    (setq projectile-switch-project-action 'projectile-dired)
    (setq projectile-require-project-root nil))
#+END_SRC

** =undo-tree=

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree)
#+END_SRC

* Language Support and Development Environments

** C / C++

   Adds custom C/C++ headers
#+BEGIN_SRC emacs-lisp
  (defun add-c-function-header( &optional n)
    "Add a default header to a subroutine"
    (interactive "P")
    (setq i 0 )
    (if n 
        (setq count n )
      (setq count (/ PERL_HEADER_LENGTH 2))
      )
    (insert "/*")
    (dotimes (i count)
      (insert "**")
      )
    (insert "\n")
    (insert " * fn::name= ")
    (yank)
    (insert "\n")
    (insert " * fn::desc= \n")
    (insert " * fn::args= \n")
    (insert " * fn::return= \n")
    (insert " * fn::notes=\n")
    (insert " * fn::todo= \n *")
    (dotimes (i (- count 1))
      (insert "**")
      )
    (insert "*/")

    )

  (defun add-c-header( &optional n )
    "Adds the header title information for the C file"
    (interactive "P")
    (let (i count ) 
      (setq count (/ PERL_HEADER_LENGTH 2))
      (insert "/*")
      (dotimes (i count) 
        (insert "**")
        )
      (insert "\n")
      (insert " * source::name= " (buffer-name) "\n")
      (insert " * source::desc=\n")
      (insert " * source::author= " (user-real-login-name) "\n")
      (insert " * source::cvs= $Id$\n")
      (insert " * source::changed= $Date$\n")
      (insert " * source::modusr= $Author$\n")
      (insert " * source::notes=\n")
      (insert " * source::todo=\n *")
      (dotimes (i (- count 1))
        (insert "**")
        )
      (insert "*/")
      )
    )
#+END_SRC

** Perl 

   Adds Perl headers
#+BEGIN_SRC emacs-lisp
  (defun add-perl-header( &optional n) 
    "Add a default header line at the start of a script"
    (interactive "P")                     ;need this for args
    (let (i j)
      (setq i 0 )
      ;;  (princ PERL_HEADER_LENGTH)
      (if n 
          (progn
            (setq count n) 
            )
        (setq count PERL_HEADER_LENGTH)
        )
      (insert "#")
      (dotimes (i count)
        (insert "*")
        )
      (let (fname prefix suffix )
        (setq fname (buffer-name))
        (string-match ".*\\.\\(.*\\)" fname)
        (setq suffix (match-string 1 fname))
        (setq prefix (perl-suffix-lookup suffix))
        (insert "\n")
        (insert "# " prefix "::name= " fname "\n")
        (insert "# " prefix "::desc=\n" )
        (insert "# " prefix "::author= " (user-real-login-name) "\n")
        (insert "# " prefix "::cvs= $Id$\n")
        (insert "# " prefix "::changed= $Date$\n")
        (insert "# " prefix "::modusr= $Author$\n")
        (insert "# " prefix "::notes=\n")
        (insert "# " prefix "::todo=\n#")
        (dotimes (i count)
          (insert "*"))
        (insert "\n")
        );let
      (insert "\n\n\n")
      ( _add-perl-divider "LIBRARIES")
      (insert "\n\n")
      ( _add-perl-divider "GLOBAL VARIABLES")
      (insert "\n\n")
      ( _add-perl-divider "CODE")
      (insert "\n\n")
      ( _add-perl-divider "SUBROUTINES")
      );let
    );defun

  (defun perl-suffix-lookup (n)
    "Looks up the tail of a perl script and determines what the header name should be"
                                          ;  (interactive "P")
    (cond ((string= n "pl") "script")
          ((string= n "pm")  "mod" )
          ((string= n "module") "mod" )
          ((string= n "script") "script")
          (t "script"))
    )

  (defun add-perl-sub-header( &optional n)
    "Add a default header to a subroutine"
    (interactive "P")
    (setq i 0 )
    (if n 
        (setq count n )
      (setq count (/ PERL_HEADER_LENGTH 2))
      )
    (insert "#")

    (dotimes (i count)
      (insert "=-")
      )
    (insert "\n")
    (insert "# sub::name= ")
    (yank)
    (insert "\n")
    (insert "# sub::desc= \n")
    (insert "# sub::args= \n")
    (insert "# sub::return= \n")
    (insert "# sub::notes= \n")
    (insert "# sub::todo=\n#")
    (dotimes (i count)
      (insert "=-")
      )
    )

  (defun _add-perl-divider( &optional n char)
    "Add a Label in the middle of a line"
    (interactive "P")
    (setq char nil)
    (if n 
        (let (strln)
          (setq strln (length n))
          (setq i 0 )
          (if n 
              (setq count n )
            (setq count (/ PERL_HEADER_LENGTH 2) )
            )
          (insert "#")
          (let (tmp_length extra) 
            (setq tmp_length (/ (- PERL_HEADER_LENGTH strln 4) 2))
            (setq extra (mod (- PERL_HEADER_LENGTH strln 4) 2))
            (dotimes (i tmp_length)
              (insert "*"))
            (insert (format "  %s  " n ))
            (dotimes (i tmp_length)
              (insert "*"))
            (if (= extra 1)
                (insert "*"))
            )

          )
      nil
      )
    t
    )

  (defun add-perl-top-banner( &optional n )
    "Adds a top banner to the Perl subroutine"
    (interactive "P")
    (let (i count)
      (if n 
          (setq count n )
        (setq count (/ PERL_HEADER_LENGTH 2))
        )
      (insert "#")
      (dotimes (i count)
        (insert "=-")
        )
      (insert "\n")
      )
    )
#+END_SRC 

** Skill 
   Formatting functions for Scheme / Skill

#+BEGIN_SRC emacs-lisp
  (defun skill-suffix-lookup (n)
    "Looks up the tail of a perl script and determines what the header name should be"
                                          ;  (interactive "P")
    (cond ((string= n "ils") "skclass")
          ((string= n "il")  "skill" )
          (t "script"))
    )

  (defun add-skill-divider( &optional n)
    "Add a Skill divider"
    (interactive "P")
    (let (function_name return_type function_args
                        args i tmp)
      (setq a (point-marker))
      (end-of-line)
      (kill-region a (point-marker))
      (setq line (car kill-ring-yank-pointer))
      (_add-skill-divider line)
      )
    )

  (defun _add-skill-divider( &optional n)
    "Add a Label in the middle of a line"
    (interactive "P")
    (if n 
        (let (strln)
          (setq strln (length n))
          (setq i 0 )
          (if n 
              (setq count n )
            (setq count (/ PERL_HEADER_LENGTH 2) )
            )
          (insert ";")
          (let (tmp_length extra) 
            (setq tmp_length (/ (- PERL_HEADER_LENGTH strln 4) 2))
            (setq extra (mod (- PERL_HEADER_LENGTH strln 4) 2))
            (dotimes (i ( / tmp_length 2 ))
              (insert "=~"))
            (insert (format "  %s  " n ))
            (dotimes (i (/ tmp_length 2 ) )
              (insert "=~"))
            (if (= extra 1)
                (insert "="))
                                          ;          (insert (format "\n%d\n" extra))
            )

          )
      nil
      )
    t
    )

  (defun add-skill-class-header( &optional n) 
    "Add a default header line at the Skill script"
    (interactive "P")                     ;need this for args
    (setq i 0 )
    ;;  (princ PERL_HEADER_LENGTH)
    (if n 
        (progn
          (setq count n) 
          )
      (setq count PERL_HEADER_LENGTH)
      )
    (insert ";")
    (dotimes (i ( / count 2 ))
      (insert "=~")
      )
    (let (fname prefix suffix) 
      (setq fname (buffer-name))
      (string-match ".*\\.\\(.*\\)" fname)
      (setq suffix (match-string 1 fname))
      (setq prefix (skill-suffix-lookup suffix))
      (insert "\n")
      (insert "; " prefix "::name= " fname "\n")
      (insert "; " prefix "::desc=\n" )
      (insert "; " prefix "::author= " (user-real-login-name) "\n")
      (insert "; " prefix "::cvs= $Id$\n")
      (insert "; " prefix "::changed= $Date$\n")
      (insert "; " prefix "::modusr= $Author$\n")
      (insert "; " prefix "::notes=\n")
      (insert "; " prefix "::todo=\n;")
      (dotimes (i (/ count 2))
        (insert "=~")
        );dotimes
      (insert "\n" )
      (insert ";\n")
      (insert ";           Copyright (c) 2009, MaxLinear, Inc\n" )
      (insert ";\n;")
      (dotimes (i (/ count 2))
        (insert "=~")
        );dotimes
      );let
    );defun

  (defun add-tex-stuff( &optional n )
    "Adds the default TeX header stuff I like"
    (interactive "P")
    (insert "\\ifdefined\\MASTERDOCUMENT\n")
    (insert "\\else\n")
    (insert "\\documentclass{article}\n")
    (insert "\\input{header}\n")
    (insert "\\begin{document}\n")
    (insert "\\fi\n")
    (insert "\\ifdefined\\MASTERDOCUMENT\n")
    (insert "\\endinput\n")
    (insert "\\else\n" )
    (insert "\\expandafter\\enddocument\n")
    (insert "\\fi\n") 
    )



  (defun add-skill-top-banner( &optional n )
    "Adds a Skill banner to the top of a subroutine"
    (interactive "P")
    (let (i count)
      (if n 
          (setq count n )
        (setq count (/ PERL_HEADER_LENGTH 2))
        )
      (indent-for-tab-command)
      (insert ";")
      (dotimes (i count)
        (insert "=~")
        )
      )
    )

  (defun add-skill-function-header( &optional n )
    "Adds a Skill function header"
    (interactive "P")
    (let (function_name function_type start end indpos indent
                        ) 
      (beginning-of-line)
      (setq start (point-marker (beginning-of-line)))
      (setq indpos (point-marker (forward-sexp)))
      (setq indent (- (marker-position indpos) (marker-position start)))
      (end-of-line)
      (copy-region-as-kill indpos (point-marker))
      (setq line (car kill-ring-yank-pointer))
                                          ;    (posix-string-match "^ *\( *\\([A-z0-9]+\\) *\(" line )
      (posix-string-match "^ *\( *\\([A-z0-9]+\\) *\(?.*$" line )
      (setq function_name ( match-string 1 line))
      (copy-region-as-kill start indpos )
      (setq line (car kill-ring-yank-pointer))
      (posix-string-match "^ *\\([A-z0-9]+\\)$" line )
      (setq function_type (match-string 1 line))
      (goto-char (marker-position start))
      (add-skill-top-banner)
      (insert "\n")
      (skill-fun-header-helper function_type function_name)
                                          ;    (add-skill-top-banner)
      (indent-for-tab-command)
      )
    )


  (defun add-perl-mod-sub-header( &optional n )
    "Adds a complex header title for the Perl subroutine"
    (interactive "P")
    (let (function_name return_type function_args
                        args search listargs counter optionalargs) 
      (setq a (point-marker))
      (setq optionalargs nil)
      (end-of-line)
      (copy-region-as-kill a (point-marker))
      (setq line (car kill-ring-yank-pointer))    
      ( posix-string-match "^ *sub +\\([A-Za-z0-9_]+\\) *(\\([&$@;%*\\ ]*\\))?" line )
      (setq function_name (match-string 1 line))
      (setq function_args (match-string 2 line))
      (setq search (posix-string-match "^\\([\\]?[@&%;$*]\\)\\(.*\\)" function_args))
      (while search
        (setq arg (match-string 1 function_args))
        (setq function_args (match-string 2 function_args))
        (setq search (posix-string-match "^\\([\\]?[&@%;$*]\\)\\(.*\\)" function_args))
        (cond ((if (eq optionalargs nil) t) 
               (cond 
                ((string= arg "\\$")  (push "(SCALAR REF)" listargs ))
                ((string= arg "\\@")  (push "(ARRAY REF)" listargs ))
                ((string= arg "\\%")  (push "(HASH REF)" listargs ))
                ((string= arg "\\*")  (push "(GLOB REF)" listargs ))
                ((string= arg "\\&")  (push "(CODE REF)" listargs ))
                ((string= arg "$" )  (push "(SCALAR)" listargs ))
                ((string= arg "@" )  (push "(ARRAY)" listargs ))
                ((string= arg "%" )  (push "(HASH)" listargs))
                ((string= arg "*" )  (push "(GLOB)" listargs))
                ((string= arg ";" )  (setq optionalargs t))
                )
               )                        ;else...
              ((string= arg "\\$")  (push "(OP:SCALAR REF)" listargs ))
              ((string= arg "\\@")  (push "(OP:ARRAY REF)" listargs ))
              ((string= arg "\\%")  (push "(OP:HASH REF)" listargs ))
              ((string= arg "\\*")  (push "(OP:GLOB REF)" listargs ))
              ((string= arg "\\&")  (push "(OP:CODE REF)" listargs ))
              ((string= arg "$" )  (push "(OP:SCALAR)" listargs ))
              ((string= arg "@" )  (push "(OP:ARRAY)" listargs ))
              ((string= arg "%" )  (push "(OP:HASH)" listargs))
              ((string= arg "*" )  (push "(OP:GLOB)" listargs))
              )
        )
      (goto-char a )
      (add-perl-top-banner)
      (insert (format "# sub::name= %s\n" function_name ) )
      (insert "# sub::desc=\n")
      (insert "# sub::args=\n")
      (setq counter 1)
      (dolist (i (reverse listargs))
        (insert (format "#              %d. %-12s:\n" counter i))
        (setq counter (+ counter 1))
        )
      (insert "# sub::return=\n")
      (insert "# sub::notes=\n")
      (insert "#              None\n")
      (insert "# sub::todo=\n")
      (insert "#              None\n")
      (add-perl-top-banner)
      )
    )

  (defun sw-add-perl-package-header( &optional n )
    "Adds a header title for a Perl Package"
    (interactive "P")
    (let (function_name return_type function_args )



      )
    )

  (defun sw-add-perl-pod-section( &optional n)
    "Adds POD documentation at the end of the file"
    (interactive "P")
    (let ( bufname )
      (insert "__END__\n")
      (insert "\n\n=head1 NAME\n\n")
      (insert (format "%s - INSERT DESCRIPTION\n\n" (buffer-name)))
      (insert "=head1 SYNOPSIS\n\n=over 12\n\n")
      (insert "=item B<fuse_layer.pl>\n\n[][]\n\n")
      (insert "=back\n\n")
      (insert "=head1 OPTIONS AND ARGUMENTS\n\n")
      (insert "=over 8\n\n")
      (insert "=head1 DESCRIPTION\n\n")
      (insert "=head1 SEE ALSO\n\n")
      (insert "=head1 AUTHOR\n\n")
      (insert "Please report bugs to jdamon@maxlinear\n\n")
      )
    ); defun


  (defun sw-add-perl-mod-sub-header( &optional n )
    "Adds a complex header title for the Perl subroutine"
    (interactive "P")
    (let (function_name return_type function_args
                        args search listargs counter optionalargs) 
      (setq a (point-marker))
      (setq optionalargs nil)
      (end-of-line)
      (copy-region-as-kill a (point-marker))
      (setq line (car kill-ring-yank-pointer))    
      ( posix-string-match "^ *sub +\\([A-Za-z0-9_]+\\) *(\\([&$@;%*\\ ]*\\))?" line )
      (setq function_name (match-string 1 line))
      (setq function_args (match-string 2 line))
      (setq search (posix-string-match "^\\([\\]?[@&%;$*]\\)\\(.*\\)" function_args))
      (while search
        (setq arg (match-string 1 function_args))
        (setq function_args (match-string 2 function_args))
        (setq search (posix-string-match "^\\([\\]?[&@%;$*]\\)\\(.*\\)" function_args))
        (cond ((if (eq optionalargs nil) t) 
               (cond 
                ((string= arg "\\$")  (push "(SCALAR REF)" listargs ))
                ((string= arg "\\@")  (push "(ARRAY REF)" listargs ))
                ((string= arg "\\%")  (push "(HASH REF)" listargs ))
                ((string= arg "\\*")  (push "(GLOB REF)" listargs ))
                ((string= arg "\\&")  (push "(CODE REF)" listargs ))
                ((string= arg "$" )  (push "(SCALAR)" listargs ))
                ((string= arg "@" )  (push "(ARRAY)" listargs ))
                ((string= arg "%" )  (push "(HASH)" listargs))
                ((string= arg "*" )  (push "(GLOB)" listargs))
                ((string= arg ";" )  (setq optionalargs t))
                )
               )                        ;else...
              ((string= arg "\\$")  (push "(OP:SCALAR REF)" listargs ))
              ((string= arg "\\@")  (push "(OP:ARRAY REF)" listargs ))
              ((string= arg "\\%")  (push "(OP:HASH REF)" listargs ))
              ((string= arg "\\*")  (push "(OP:GLOB REF)" listargs ))
              ((string= arg "\\&")  (push "(OP:CODE REF)" listargs ))
              ((string= arg "$" )  (push "(OP:SCALAR)" listargs ))
              ((string= arg "@" )  (push "(OP:ARRAY)" listargs ))
              ((string= arg "%" )  (push "(OP:HASH)" listargs))
              ((string= arg "*" )  (push "(OP:GLOB)" listargs))
              )
        )
      (goto-char a )
      (add-perl-top-banner)
      (insert (format "# Name     : %s\n" function_name ) )
      (insert "# Desc     :\n")
      (insert "# Args     :\n")
      (setq counter 1)
      (dolist (i (reverse listargs))
        (insert (format "#              %d. %-12s:\n" counter i))
        (setq counter (+ counter 1))
        )
      (insert "# Returns  :\n")
      (insert "# Throws   :\n")
      (insert "# Notes    :\n")
      (insert "#              none\n")
      (insert "# Todo     :\n")
      (insert "#              none\n")
      (add-perl-top-banner)
      )
    )
                                          ;------------------------------------------------------------------------------
                                          ;
                                          ; fn::name= add-c-mod-function-header
                                          ; fn::desc= adds a C function header
                                          ; fn::args= 1: optional, that describes number of characers
                                          ; fn::desc= 1. Goal is to extract from a given line, the args passed to the
                                          ;              function, and the arguments that are returned back to the
                                          ;              user itself.
                                          ; 
                                          ; fn::todos= 1. Paste the elements from the start of the line until the
                                          ;               end of the line into a buffer.............................DONE!
                                          ;            2. Save the current point, and then insert the text above
                                          ;               it........................................................DONE!
                                          ;            3. Eventually allow functions to span multiple lines until it
                                          ;               reaches the '{' character.................................
                                          ;            4. Correctly parse Pointers to functions.....................
                                          ;
                                          ;            5. Allow correct matching for a term such as follows:
                                          ;               const void *key... would be const void *..................DONE!
                                          ;            6. Allow pointer to pointer declarations.....................DONE!
                                          ;
                                          ;            7. Add fix to allow for  function declarations that return
                                          ;               pointers, like :  static int *function()..................DONE!
                                          ;            8. Add fix for base case, such as void Do_something(void)
                                          ;               and just pick up void.....................................
                                          ;------------------------------------------------------------------------------
  (defun add-c-mod-function-header( &optional n)
    "Add a default header to a subroutine"
    (interactive "P")
    (let (function_name return_type function_args
                        args i tmp)
      (setq a (point-marker))
      (end-of-line)
      (copy-region-as-kill a (point-marker))
      (setq line (car kill-ring-yank-pointer))    
                                          ;    (string-match "\\(.*\\) +\\([A-Za-z0-9_-\\*]+\\) *( *\\([^)]*\\) *) *{?" line)
      (string-match "\\(.* +\\** *\\)\\([A-Za-z0-9_-]+\\) *( *\\([^)]*\\) *) *{?" line)
      (setq return_type (match-string 1 line))
      (setq function_name (match-string 2 line))
      (setq function_args (match-string 3 line))
      (setq args (split-string function_args "," )) ; Split on the commas...
      (goto-char a)
      (insert "\n")
      (if n 
          (setq count n )
        (setq count (/ PERL_HEADER_LENGTH 2)  )
        )
      (insert "/*")
      (dotimes (i count)
        (insert "**")
        )
      (insert "\n")
      (insert " * fn::name= " function_name "\n" )
      (insert " * fn::desc= \n")
      (insert " * fn::args= \n")
      (setq i 1)
      (dolist (value args)
        (stringp value)
        (posix-string-match "^ *\\([A-Za-z0-9_ ]+\\**\\)\\b\\w+" value)
        (setq tmp (match-string 1 value))
        (insert (format " *%12s%d (%s): \n" " " i tmp) )
        (setq i (+ i 1))
        )
      (insert " * fn::return=\n")
      (insert (format " *%12s%s: \n" " " return_type ))
      (insert " * fn::notes=\n")
      (insert " * fn::todo= \n *")
      (dotimes (i (- count 1))
        (insert "**")
        )
      (insert "*/\n")
      )
    )

#+END_SRC

** ROS Launch file support 
#+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.launch\\'" . xml-mode))
#+END_SRC

** Other languages
#+BEGIN_SRC emacs-lisp
  (autoload 'vht-mode         "verilog"      "Vht programming mode" t)
  (autoload 'c++-mode         "cc-mode"      "C++ programming mode" t)
  (autoload 'c-mode           "cc-mode"      "C programming mode" t)
  (autoload 'cvs-update       "pcl-cvs" t)
  (autoload 'cvs-update-other-window "pcl-cvs" t)
  (autoload 'hexl-find-file   "hexl"     "Edit file in hexl-mode." t)
  (autoload 'perl-mode        "perl"     "Perl programming mode" t)
  (autoload 'rdf-mode         "rdf"      "RDF analysis mode" t)
  (autoload 'tm-mode          "tm"       "Time budget mode" t)
  (autoload 'tcl-mode         "tcl"      "Tcl programming mode" t)
  (autoload 'verilog-mode     "verilog"  "Verilog programming mode" t)
  (autoload 'vm               "vm"       "VM mail reader" t)
  (autoload 'spice-mode       "spice"    "Spice Mode"  t)
  (autoload 'spectre-mode "spectre-mode" "Spectre Editing Mode" t)
#+END_SRC

** Linux Kernel Development
#+BEGIN_SRC emacs-lisp
  (defun c-lineup-arglist-tabs-only (ignored)
    "Line up argument lists by tabs, not spaces"
    (let* ((anchor (c-langelem-pos c-syntactic-element))
           (column (c-langelem-2nd-pos c-syntactic-element))
           (offset (- (1+ column) anchor))
           (steps (floor offset c-basic-offset)))
      (* (max steps 1)
         c-basic-offset)))

  (add-hook 'c-mode-common-hook
            (lambda ()
              ;; Add kernel style
              (c-add-style
               "linux-tabs-only"
               '("linux" (c-offsets-alist
                          (arglist-cont-nonempty
                           c-lineup-gcc-asm-reg
                           c-lineup-arglist-tabs-only))))))

  (add-hook 'c-mode-hook
            (lambda ()
              (let ((filename (buffer-file-name)))
                ;; Enable kernel mode for the appropriate files
                (when (and filename
                           (string-match (expand-file-name "~/src/linux-trees")
                                         filename))
                  (setq indent-tabs-mode t)
                  (c-set-style "linux-tabs-only")))))

#+END_SRC


** Maxima 
#+BEGIN_SRC emacs-lisp
  (setq imaxima-fnt-size "Huge")
#+END_SRC

** Tramp setup
#+BEGIN_SRC emacs-lisp
;   (require 'tramp)
;   (setq tramp-default-method "ssh")
#+END_SRC

** Doxymacs
#+BEGIN_SRC emacs-lisp
  (condition-case nil
      (require 'doxymacs)
    (setq doxymacs-doxygen-style "JavaDoc")
    (add-hook 'c-mode-common-hook'doxymacs-mode)
    (add-hook 'c++-mode-common-hook'doxymacs-mode)
    (error nil)
    )
#+END_SRC


** Spice

** Ruby

I use =chruby= to switch between versions of Ruby. This sets a default version
to use within Emacs (for things like =xmp= or =rspec=).

#+BEGIN_SRC emacs-lisp
  (setq jmd/ruby-version "2.5.3")

  (use-package chruby
    :config
    (chruby jmd/ruby-version))
#+END_SRC

Ruby executables are installed in =~/.gem/ruby/<version>/bin=. This ensures that
that's included in the path. In particular, we want that directory to be
included because it contains the =xmpfilter= executable, which is used below.

#+BEGIN_SRC emacs-lisp
  (jmd/append-to-path (format "~/.gem/ruby/%s/bin" jmd/ruby-version))
#+END_SRC

Running tests from within Emacs is awfully convenient.

#+BEGIN_SRC emacs-lisp
  (use-package rspec-mode)
#+END_SRC

=rcodetools= provides =xmp=, which lets me evaluate a Ruby buffer and display
the results in "magic" (=# =>=) comments.

I disable warnings when running code through =xmp= because I disagree with a few
of them (complaining about private =attr_reader=, especially) and they gunk up
my buffer.

* Extra stuff
#+BEGIN_SRC emacs-lisp
	 ;; (add-hook 'emacs-lisp-mode-hook
	 ;;             (lambda ()
	 ;;               (push '(">=" . ?≥) prettify-symbols-alist)))
	 ;; (lambda (x y)
	 ;;   (if (>= x y)
	 ;;       (something)
	 ;;     (something-else)))

	 ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
	 ; Useful for copying and pasting in emacs in a terminal
	 ; Not sure if this will cause a bug or not
	 ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
	 (defun now ()
	   "Insert string for the current time formatted like '2:34 PM' or 1507121460"
	   (interactive)                 ; permit invocation in minibuffer
	   (insert (format-time-string "%D %-I:%M %p"))
	 )

	 ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
	 ; Compilation stuff
	 ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
	 (defun save-all-and-compile ()
	   (save-some-buffers 1)
	   (compile compile-command))

	 (setq compilation-ask-about-save nil)
	 (global-set-key [f5] 'compile)

	 (setq TeX-PDF-from-DVI "Dvips") 
	 ;; (add-to-list 'load-path "/home/jdamon/.emacs.d/share/emacs/site-lisp")
	 ;; (add-to-list 'load-path "/usr/share/emacs24/site-lisp/")
	 ;; (add-to-list 'load-path "/usr/share/emacs24/site-lisp/auto-complete");
	 ;; (condition-case nil
	 ;; (require 'auto-complete-config)
	 ;; (add-to-list 'ac-dictionary-directories "/usr/share/emacs23/site-lisp//ac-dict")
	 ;; (ac-config-default)
	 ;; (error nil)
	 ;; )
	 ;; (add-to-list 'load-path "/home/jdamon/.emacs.d/neotree" )
	 ;; (require 'neotree)
	 ;; (global-set-key [f8] 'neotree-toggle)
	 ;check system name
	 (add-to-list 'load-path "/home/jdamon/.emacs.d/lisp")
	 (add-to-list 'load-path "/home/jdamon/.emacs.d/xcscope")
	 (add-to-list 'load-path "/usr/share/emacs23/site-lisp/")

	 (condition-case nil
	   (load "auctex.el" nil t t)
	   (load "preview-latex.el" nil t t)
	   (error nil)
	 )

	 (condition-case nil
	   (load "ggtags.elc" nil t t )
	   (add-hook 'c-mode-common-hook
		     (lambda ()
		       (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
			 (ggtags-mode 1))))
	   (error nil)
	 )
	 ;; (load "smart-compile.el" nil t t )
	 ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
	 ; Auto compilation
	 ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
	 ;; (load "mode-compile.el" nil t t )
	 (defun mode-compile-quiet ()
	   (interactive)
	   (flet ((read-string (&rest args) ""))
	     (mode-compile)))

	 ;; Bury the compilation buffer when compilation is finished and successful.
	 (add-to-list 'compilation-finish-functions
		      (lambda (buffer msg)
			(when 
			  (bury-buffer buffer)
			  (replace-buffer-in-windows buffer))))

	 ;; C-c C-% will set a buffer local hook to use mode-compile after saving
	 (global-set-key '[(ctrl c) (ctrl %)]
			 (lambda () 
			   (interactive)
			   (if (member 'mode-compile-quiet after-save-hook)
			       (progn
				 (setq after-save-hook 
				     (remove 'mode-compile-quiet after-save-hook))
				 (message "No longer compiling after saving."))
			     (progn
			       (add-to-list 'after-save-hook 'mode-compile-quiet)
			       (message "Compiling after saving.")))))

	 ;; Prevent compilation buffer from showing up
	 ;; (defadvice compile (around compile/save-window-excursion first () activate)
	 ;;   (save-window-excursion ad-do-it))

	 ;; Bury the compilation buffer when compilation is finished and successful.
	 (add-to-list 'compilation-finish-functions
		      (lambda (buffer msg)
			(when 
			  (bury-buffer buffer)
			  (replace-buffer-in-windows buffer))))

	 (setq compilation-scroll-output 'first-error)

	 ;; (require  'xcscope )
	 (define-key global-map [(control f4)]  'cscope-pop-mark)
	 (define-key global-map [(control f5)]  'cscope-find-this-text-string)
	 (define-key global-map [(control f6)]  'cscope-find-this-symbol)
	 (define-key global-map [(control f7)]  'cscope-find-functions-calling-this-function)
	 (define-key global-map [(control f8)]  'cscope-find-called-functions)
	 (define-key global-map [(control f9)]  'cscope-prev-symbol)
	 (define-key global-map [(control f10)] 'cscope-next-symbol)
	 ;;; XEmacs backwards compatibility file


	 (line-number-mode t)
	 ;(put 'my-operator 'scheme-indent-function 3)
	 ; Stuff for setting up key bindings...
	 ;; (add-to-list 'load-path "~/.emacs.d/")


	 (condition-case nil
	   (require 'auto-complete-config)
	   (error nil)
	 )    

	 (defun describe-face-at-point ()
		       "Return face used at point."
		       (interactive)
		       (hyper-describe-face (get-char-property (point) 'face)))

	 (defun jump-down (&optional n )
	   "Jump downwards by n secions of 8 lines"
	   (interactive "P")
	   (let (i count)
	     (if n
		 (progn 
		   (setq count n)
		 )
		 (setq count 1)
	     )
	     (dotimes ( i count)
	       (forward-line (* 8 (+ i 1)))
	     )
	   )
	 )

	 (defun jump-up (&optional n )
	   "Jump upwards by n sections of 8 lines"
	   (interactive "P")
	   (let (i count)
	     (if n
		 (progn 
		   (setq count n)
		 )
		 (setq count 1)
	     )
	     (dotimes ( i count)
	       (forward-line (* -8 (+ i 1)))
	     )
	   )
	 )

	 (defun charlie-settings( &optional n )
	   "Setup the charlie settings"
	   (interactive "P")
	   (c-set-offset 'statement-block-intro 4)
	   (c-set-offset 'defun-block-intro 4)
	 )



	 (setq-default indent-tabs-mode nil)     ; Turn off default tabs
	 (setq inhibit-startup-message t)        ; Turn off start up message
	 (setq inhibit-default-init t)           ; Turn off default init and messages
	 (setq home-dir (getenv "HOME"))
	 (defvar PERL_HEADER_LENGTH 76
	   "Controls the length of headers")

	 ;; (setq load-path (cons (expand-file-name "~/Emacs") load-path))
	 ;; (setq load-path (cons (expand-file-name "~/.emacs.d") load-path))
	 ;; (setq load-path (cons "/usr/share/emacs/site-lisp/site-start.d" load-path))

	 (global-set-key [(control button2)] 'x-copy-primary-selection)
	 (global-set-key [(button4)] 'scroll-down)
	 (global-set-key [(button5)] 'scroll-up)
	 (global-set-key "\M-[a" 'jump-up)
	 (global-set-key "\M-[b" 'jump-down)

	 (global-set-key "\C-b" 'backward-kill-word)
	 (global-set-key "\C-n" 'kill-word)
	 (global-set-key "\M-?" 'help-command)
	 ;; (global-set-key "\C-h" 'delete-backward-char) ; get rid of those annoying character
	 (global-set-key "\M-\C-s" 'shell)
	 (global-set-key "\M-\C-l" 'toggle-buffers-in-window)
	 (global-set-key "\C-xg" 'goto-line)
	 ;; (global-set-key "\C-h" 'delete-backward-char)
	 (global-set-key "\C-c\C-c" 'comment-region)
	 ;(global-set-key [(control left)]  'backward-word-correctly )
	 ;(global-set-key [(control right)] 'forward-word-correctly )
	 (global-set-key [(control right)] 'forward-word)
	 (global-set-key [(control left)]  'backward-word )
	 ;(global-set-key [(control down)]  'jump-down )
	 ;(global-set-key [(control up )]   'jump-up )

	 ;(global-set-key "\C-" 'backward-paragraph)
	 (define-key global-map [(control bracket)] 'backward-paragraph)
	 (defalias 'scroll-ahead 'scroll-up)
	 (defalias 'scroll-behind 'scroll-down)






	 ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
	 ; 
	 ; Defined functions for customization 
	 ;
	 ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-




	 (defun scroll-n-lines-ahead ( &optional n )
	   "Scroll Ahead N lines( 1 by default )."
	   (interactive "P")
	   (scroll-ahead (prefix-numeric-value n)))
	 (defun scroll-n-lines-behind (&optional n)
	   "Scroll Behind N lines( 1 by default )."
	   (interactive "P")
	   (scroll-behind (prefix-numeric-value n)))

	 ;:*======================



	 (defun lets-test-it (&optional n )
	   "Examining the characteristics of parameters"
	   (interactive)                         ;no args
	   (princ n)
	 )

	 (require 'font-lock)


	 (defvar null-device "/dev/null")
	 ;; (set-face-foreground 'font-lock-type-face'            "dodgerblue")
	 ;;(message "Making pretty Colors")
	 ;;(message "HELLO THERE")
	 ;(load-file "/Users/jdamon/Emacs/spice-mode.el")
	 ;(load-file "/Users/jdamon/Emacs/modes.el")
	 (setq auto-mode-alist (append (list (cons "\\.scs$" 'spectre-mode)
					     (cons "\\.inp$" 'spectre-mode))
				       auto-mode-alist))






	 ; (add-hook 'LaTeX-mode-hook #'LaTeX-install-toolbar)

	 (setq perl-indent-level 4)
	 (setq cperl-indent-level 4)
	 (setq cperl-font-lock t)
	 (setq cperl-syntaxify-by-font-lock t)
	 ;(cperl-set-style "BSD")   ; Need to find a way to specify the style with a variable...


	 (add-hook 'cperl-hook-mode 'outline-minor-mode)


	 (line-number-mode t)
	 (display-time )
	 (defun refill-mode (&optional arg)
	   "Refill Minor Mode"
	   (interactive "P")
	   (setq refill-mode
		 (if (null arg)
		     (not refill-mode)
		     (> (prefix-numeric-value arg) 0))

	   )
	   (make-local-hook 'after-change-functions)
	   (if refill-mode
	       (add-hook 'after-change-functions 'refill nil t)
	       (remove-hook 'after-change-functions 'refill t)
	   )
	 )




	 (defun writeroom ()
	   "Switches to a WriteRoom-like fullscreen style"
	   (interactive) 
	   (when (featurep 'aquamacs)
	     ;; switch to white on black
	     ;; (color-theme-initialize)
	     ;; (color-theme-clarity)
	     ;; (color-theme-scintilla)
	     ;; switch to Garamond 36pt
	     (aquamacs-autoface-mode 0)
	     (set-frame-font "-apple-garamond-medium-r-normal--36-360-72-72-m-360-iso10646-1")
	     ;; switch to fullscreen mode
	     (aquamacs-toggle-full-frame)))


	 (defun iconify-or-deiconify-frame-fullscreen-even ()
	    (interactive)
	    (if (eq (cdr (assq 'visibility (frame-parameters))) t)
	      (progn
		(if (frame-parameter nil 'fullscreen) 
		(aquamacs-toggle-full-frame))     
	  ;       (switch-to-buffer "*scratch*") 
		(iconify-frame))
	      (make-frame-visible))) 
	  (define-key global-map "\C-z" #'iconify-or-deiconify-frame-fullscreen-even)


	 (defun skill-fun-header-helper( name function_name )
	 "Extra helper function that uses the name and extra to setup headers"
	     (indent-for-tab-command)
	     (insert (format "; %s::name=     : %s\n" name function_name ) )
	     (indent-for-tab-command)
	     (insert (format "; %s::desc=     :\n" name ))
	     (indent-for-tab-command)
	     (insert (format "; %s::args=     :\n" name ))
	     (setq counter 1)
	     (indent-for-tab-command)
	     (insert (format "; %s::returns=  :\n" name ))
	     (indent-for-tab-command)
	     (insert (format "; %s::throws=   :\n" name ))
	     (indent-for-tab-command)
	     (insert (format "; %s::notes=    :\n" name ))
	     (indent-for-tab-command)
	     (insert (format ";              none\n"))
	     (indent-for-tab-command)
	     (insert (format "; %s::todo     :\n" name ))
	     (indent-for-tab-command)
	     (insert (format ";              none\n"))
	     (add-skill-top-banner)
	     (insert "\n")
	 )


	 ;; (add-hook 'c-mode-common-hook 'doxymacs-mode)
	 ;(add-hook 'c-mode-common-hook 'hl-line-mode)
	 (add-hook 'c-mode-common-hook 'linum-mode)
	 (add-hook 'c-mode-common-hook 'outline-minor-mode ) 
	 (add-hook 'python-mode-hook 'linum-mode)


	 ;************************* Custimization of Faces *******************************


	 ;; (custom-set-variables
	 ;;  ;; custom-set-variables was added by Custom.
	 ;;  ;; If you edit it by hand, you could mess it up, so be careful.
	 ;;  ;; Your init file should contain only one such instance.
	 ;;  ;; If there is more than one, they won't work right.
	 ;;  '(markdown-command "pandoc ")
	 ;;  '(org-agenda-files nil)
	 ;;  '(org-modules
	 ;;    (quote
	 ;;     (org-bbdb org-bibtex org-ctags org-docview org-gnus org-info org-irc org-mhe org-rmail org-w3m org-drill org-learn)))
	 ;;  '(package-selected-packages
	 ;;    (quote
	 ;;     (cedit cdlatex ledger-import flycheck-ledger org-babel-eval-in-repl graphviz-dot-mode dot-mode org-drill-table dash yaml-mode scala-mode polymode passthword org-bullets org neotree markdown-mode json-mode groovy-mode gradle-mode gitignore-mode color-theme-modern cmake-mode chess bind-key auto-complete auctex))))
	 ;; (load-library "color-theme")
	 ;
	 ;(color-theme-select)
	 ;(color-theme-scintilla)
	 ;; '(font-lock-comment-face ((t (:foreground "pale green" :slant italic))))



	 (put 'upcase-region 'disabled nil)
	 (put 'downcase-region 'disabled nil)
	 ;(princ edit-tab-stops-map)

	 ;;; This was installed by package-install.el.
	 ;;; This provides support for the package system and
	 ;;; interfacing with ELPA, the package archive.
	 ;;; Move this code earlier if you want to reference
	 ;;; packages in your .emacs.
	 ;; (if nil
	 ;;     (when
	 ;;         (load
	 ;;          (expand-file-name "~/.emacs.d/elpa/package.el"))
	 ;;       (package-initialize))
	 ;; )


	 (defun bisque-background()
	   "Switches to bisque background for better vision"
	   (interactive) 
	   (set-background-color "bisque")
	   (custom-set-faces
	   '(hl-line ((t (:background "tan1"))))
	   '(font-lock-string-face ((t (:foreground "medium orchid"))))
	   )
	 )

	 (if (display-graphic-p) 
	   () 
	   (load-theme 'wheatgrass)
	   (xterm-mouse-mode)
	 )


	 (defun my-add-semantic-to-autocomplete()
	   (add-to-list 'ac-sources 'ac-source-semantic)
	   )

	 (add-hook 'c-mode-common-hook 'my-add-semantic-to-autocomplete)
	 (electric-indent-mode -1)
	 (defun toggle-window-split ()
	   (interactive)
	   (if (= (count-windows) 2)
	       (let* ((this-win-buffer (window-buffer))
		      (next-win-buffer (window-buffer (next-window)))
		      (this-win-edges (window-edges (selected-window)))
		      (next-win-edges (window-edges (next-window)))
		      (this-win-2nd (not (and (<= (car this-win-edges)
						  (car next-win-edges))
					      (<= (cadr this-win-edges)
						  (cadr next-win-edges)))))
		      (splitter
		       (if (= (car this-win-edges)
			      (car (window-edges (next-window))))
			   'split-window-horizontally
			 'split-window-vertically)))
		 (delete-other-windows)
		 (let ((first-win (selected-window)))
		   (funcall splitter)
		   (if this-win-2nd (other-window 1))
		   (set-window-buffer (selected-window) this-win-buffer)
		   (set-window-buffer (next-window) next-win-buffer)
		   (select-window first-win)
		   (if this-win-2nd (other-window 1))))))


	 ; Set the equation to be larger sized
	 (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
	 (setq org-display-inline-images t) 
	 (setq org-redisplay-inline-images t) 
	 (setq org-startup-with-inline-images "inlineimages")


   ;  (require 'calendar)



       (setq epa-file-cache-passphrase-for-symmetric-encryption t )
       (setq org-deadline-warning-days 0)
  (use-package flycheck-ledger :after ledger-mode )

  (setq org-return-follows-link t )
  (require 'org-jira)
  (setq jiralib-url "https://automodality.atlassian.net")

#+END_SRC 

* Publishing and task management with Org-mode
#+BEGIN_SRC emacs-lisp
  (use-package org)
#+END_SRC

** Org Setup
*** Org Directory Setup
#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/Projects/org")
  (add-hook 'org-mode-hook 'outline-minor-mode)
#+END_SRC

*** Scaling Preview Latex 
#+BEGIN_SRC emacs-lisp
  (set-default 'preview-scale-function 1.9 )
#+END_SRC

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook 'org-bullets-mode))
  ;; (add-hook 'org-mode-hook
  ;;           (lambda ()
  ;;             (org-bullets-mode t )))
#+END_SRC

I borrowed this from Harry Schwartz as I too "like seeing a little
downward-pointing arrow instead of the usual ellipsis (=...=) that org
displays when there's stuff under a header."
#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC 

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

Hiding leading stars
#+BEGIN_SRC emacs-lisp
  (setq org-hide-leading-stars t)
#+END_SRC

** Extra Org stuff
** Org Inbox, Index and Archive location 
 #+BEGIN_SRC emacs-lisp
   (defun org-file-path (filename)
     "Return the absolute address of an org file, given its relative name."
     (concat (file-name-as-directory org-directory) filename))

   (setq org-inbox-file "~/Dropbox/inbox.org")
   (setq org-index-file (org-file-path "index.org"))
   (setq org-archive-location
         (concat (org-file-path "archive.org") "::"))
#+END_SRC

** Archiving Org mode entries
#+BEGIN_SRC emacs-lisp
   (defun jmd/personal-mark-done-and-archive ()
     "Mark the state of an org-mode item as DONE and archive it."
     (interactive)
     (org-todo 'done)
     (org-archive-subtree)
     (setq foo (org-get-tags-string)))

   (defun jmd/mark-work-done-and-archive ()
     "Mark the state of an org-mode item as DONE and archive it."
     (interactive)
     (org-todo 'done)
     (org-toggle-tag "work" )
     (org-archive-subtree)
     (setq foo (org-get-tags-string)))

   (defun my/org-checkbox-todo ()
     "Switch header TODO state to DONE when all checkboxes are ticked, to TODO otherwise"
     (let ((todo-state (org-get-todo-state)) beg end)
       (unless (not todo-state)
         (save-excursion
           (org-back-to-heading t)
           (setq beg (point))
           (end-of-line)
           (setq end (point))
           (goto-char beg)
           (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                                  end t)
               (if (match-end 1)
                   (if (equal (match-string 1) "100%")
                       (unless (string-equal todo-state "DONE")
                         (org-todo 'done))
                     (unless (string-equal todo-state "TODO")
                       (org-todo 'todo)))
                 (if (and (> (match-end 2) (match-beginning 2))
                          (equal (match-string 2) (match-string 3)))
                     (unless (string-equal todo-state "DONE")
                       (org-todo 'done))
                   (unless (string-equal todo-state "TODO")
                     (org-todo 'todo)))))))))


   (define-key org-mode-map (kbd "C-c C-x C-s") 'hrs/mark-done-and-archive)

#+END_SRC

** Rest of ORG

#+BEGIN_SRC emacs-lisp

   (defun org-journal-find-location ()
     ;; Open today's journal, but specify a non-nil prefix argument in order to
     ;; inhibit inserting the heading; org-capture will insert the heading.
     (org-journal-new-entry t)
     ;; Position point on the journal's top-level heading so that org-capture
     ;; will add the new entry as a child entry.
     (goto-char (point-min)))

   (setq org-src-fontify-natively t )
   (setq org-src-tab-acts-natively t )
   (setq org-src-window-setup 'current-window )
   (setq org-clock-persist 'history)
   (setq org-log-done t)
   (setq org-log-into-drawer t)
   (setq org-tags-column 80)
   (setq org-capture-templates
         '(("t" "Todo" entry (file+headline "~/Projects/org/todo.org" "Tasks")
            "* TODO %?\n%i\n   %a")
           ("j" "Journal" entry (function org-journal-find-location)
            "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")
                                           ;                 ("j" "Journal" entry (file+olp+datetree "~/Projects/org/journal.org")
                                           ;                  "* %?\nEnterered on %U\n   %i\n   %a")
           ("W" "Work Journal" entry (file+olp+datetree "~/Projects/org/workjournal.org")
            "* %?\nEnterered on %U\n   %i\n   %a")
           ("f" "Finished book"
            table-line (file "~/Documents/notes/books-read.org")
            "| %^{Title} | %^{Author} | %u |")
           ("s" "Subscribe to an RSS feed"
            plain
            (file "~/Documents/rss/urls")
            "%^{Feed URL} \"~%^{Feed name}\"")
           ))

   (setq org-hide-emphasis-markers t )

   (org-babel-do-load-languages
    'org-babel-load-languages
    '((python . t)
      (ledger . t)
      (latex . t)
      (ditaa . t)
      (shell . t)
      (dot . t)
      (ruby . t)
      (scala . t)
      (kotlin . t)
      ))
   ;;
                                           ;(setq org-journal-dir "/home/jdamon/Projects/org/journal")
                                           ;         (customize-set-variable 'org-journal-dir "~/Projects/org/journal/")
                                           ;         (customize-set-variable 'org-journal-date-format "%A, %d %B %Y")
                                           ;         (customize-set-variable 'org-journal-file-type 'monthly)
                                           ;         (require 'org-journal)
                                           ;

   (defun org-journal-save-entry-and-exit()
     "Simple convenience function.
              Saves the buffer of the current day's entry and kills the window
              Similar to org-capture like behavior"
     (interactive)
     (save-buffer)
     (kill-buffer-and-window))

   ;;----------------------------------------------------------------------
   ;; OS specific

   (cond
    ((string-equal system-type "windows-nt") ; Microsoft Windows

     (progn
       (setq-default ispell-program-name "C:/bin/Aspell/bin/aspell.exe") 
       (setq org-ditaa-jar-path "c:/bin/ditaa/ditaa.jar")
       )
     )
    ((string-equal system-type "gnu/linux") ; Linux
     (progn
       (setq x-select-enable-clipboard t)
       (setq org-ditaa-jar-path "/usr/bin/ditaa")
       )
     )
    )


                                           ;(ledger . t)
                                           ; Use this to save my location in files when i reopen them
   (save-place-mode t)

   (org-clock-persistence-insinuate)
   (defun org-archive-done-tasks ()
     (interactive)
     (org-map-entries
      (lambda ()
        (org-archive-subtree)
        (setq org-map-continue-from (outline-previous-heading)))
      "/DONE" 'tree))
   (global-set-key "\C-cl" 'org-store-link)
   (global-set-key "\C-ca" 'org-agenda)
   (global-set-key "\C-cc" 'org-capture)
   (global-set-key "\C-cb" 'org-switchb)



   (defun org-agenda-skip-deadline-if-not-thisweek ()
     "If this function returns nil, the current match should not be skipped.
               Otherwise, the function must return a position from where the search
               should be continued."
     (ignore-errors
       (let ((subtree-end (save-excursion (org-end-of-subtree t)))
             (deadline-day
              (time-to-days
               (org-time-string-to-time
                (org-entry-get nil "DEADLINE"))))
             (now (time-to-days (current-time))))
         (and deadline-day
              (not (= deadline-day now))
              subtree-end))))
   (setq org-agenda-start-with-log-mode '(closed clock state))
   (setq org-agenda-log-mode-items '(closed clock state))
   (setq org-agenda-custom-commands
         '(("c" "Simple agenda view"
            ((agenda "")
             (alltodo "")))
           ("h" "Work Things"
            ((agenda "" ((org-agenda-ndays 1)
                         (org-agenda-sorting-strategy
                          (quote ((agenda time-up priority-down tag-up))))
                         (org-deadline-warning-days 0)))
             ))
           ("W" "Weely review"
            ((agenda ""
                     ((org-agenda-span 'week)
                      (org-agenda-start-on-weekday 0)
                      (org-agenda-start-with-log-mode '(closed clock state))
                      ;; (org-agenda-skip-function
                      ;;  '(org-agenda-skip-entry-if 'nottodo 'done))
                      )))
            )
           ))

   (defun jmd-org-tasks-closed-in-month (&optional month year match-string)
     "Produces an org agenda tags view list of the tasks completed 
        in the specified month and year. Month parameter expects a number 
        from 1 to 12. Year parameter expects a four digit number. Defaults 
        to the current month when arguments are not provided. Additional search
        criteria can be provided via the optional match-string argument "
     (interactive)
     (let* ((today (calendar-current-date))
            (for-month (or month (calendar-extract-month today)))
            (for-year  (or year  (calendar-extract-year today))))
       (org-tags-view nil 
                      (concat
                       match-string
                       (format "+CLOSED>=\"[%d-%02d-01]\"" 
                               for-year for-month)
                       (format "+CLOSED<=\"[%d-%02d-%02d]\"" 
                               for-year for-month 
                               (calendar-last-day-of-month for-month for-year))))))

   (defun jmd-org-tasks-query-for-month (&optional month year)
     (interactive)
     (let* ((today (calendar-current-date))
            (for-month (or month (calendar-extract-month today)))
            (for-year  (or year  (calendar-extract-year today))))
       (concat
        (format "+CLOSED>=\"[%d-%02d-01]\"" for-year for-month)
        (format "+CLOSED<=\"[%d-%02d-%02d]\"" for-year for-month  (calendar-last-day-of-month for-month for-year)))
       ))

   (defun jmd-work-tasks-last-month ()
     "Produces an org agenda tags view list of all the tasks completed
          last month with for work "
     (interactive)
     (let* ((today (calendar-current-date))
            (for-month (calendar-extract-month today))
            (for-year  (calendar-extract-year today)))
       (calendar-increment-month for-month for-year -1)
       (org-tags-view nil (concat "TODO=\"DONE\"" 
                                  (jmd-org-tasks-query-for-month for-month for-year) 
                                  "|ARCHIVE_ITAGS=\"work\""
                                  (jmd-org-tasks-query-for-month for-month for-year)))))

   ;; (define-key org-journal-mode-map (kbd "C-x C-s") 'org-journal-save-entry-and-exit)
 #+END_SRC

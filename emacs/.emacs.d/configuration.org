#+TITLE: Emacs Configuration
#+AUTHOR: Jimi Damon
#+EMAIL: jdamon@gmail.com
#+OPTIONS: toc:nil num:nil


* Configure =use-package=

I use =use-package= to install and configure my packages. My =init.el= includes
the initial setup for =package.el= and ensures that =use-package= is installed,
since I wanna do that right away.

This makes sure that =use-package= will install the package if it's not already
available. It also means that I should be able to open Emacs for the first time
on a fresh Debian box and have my whole environment automatically installed. I'm
not /totally/ sure about that, but we're gettin' close.

#+BEGIN_SRC emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
  ;(setq load-prefer-newer nil)
#+END_SRC

Always compile packages, and use the newest version available.

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  ;(setq load-prefer-newer nil)
#+END_SRC

* Personal information
** Who am I? Where am I?

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Jimi Damon"
        user-mail-address "jdamon@gmail.com"
        calendar-latitude 32.7157
        calendar-longitude -117.1611
        calendar-location-name "San Diego, CA")
#+END_SRC

* Utility Functions

  Functions that came from Harry Schwartz's configuration.org , I just renamed them to jmd ( my
  name ) so that they're easier to remember.
#+BEGIN_SRC emacs-lisp
  (defun jmd/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun jmd/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))

  (defun jmd/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))
#+END_SRC

* UI preferences
** Tweak window chrome

No scroll bar , Tool bar or Menu bar, with a simple function to restore it

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
  (defun jmd/show-menu ()
    "Enables the menu"
    (interactive)
    (menu-bar-mode 1))
#+END_SRC

There's a tiny scroll bar that appears in the minibuffer window. This disables
that:

#+BEGIN_SRC emacs-lisp
  (set-window-scroll-bars (minibuffer-window) nil nil)
#+END_SRC

The default frame title isn't useful. This binds it to the name of the current
project:

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+END_SRC

** Use fancy lambdas

Why not?

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Load up a theme

I'm currently using the "sanityinc-tomorrow-bright" theme. I like a barely transparent 
window on top of a cool european city backdrop. I like the Sanityinc tomorrow theme, but 
I'm still not sure why this can't be loaded through use-package

#+BEGIN_SRC emacs-lisp
  (require 'color-theme-sanityinc-tomorrow)
  
  (defun transparency (value)
    "Sets the transparency of the frame window. 0=transparent/100=opaque."
    (interactive "nTransparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))

  (defun jmd/apply-theme ()
    "Apply the `solarized-light' theme and make frames just slightly transparent."
    (interactive)
    (color-theme-sanityinc-tomorrow-bright)
    ;; (load-theme 'solarized-light t)
    (transparency 96))
#+END_SRC

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+BEGIN_SRC emacs-lisp
  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (with-selected-frame frame (jmd/apply-theme))))
    (jmd/apply-theme))
#+END_SRC

** Use =moody= for a beautiful modeline

This gives me a truly lovely ribbon-based modeline.

#+BEGIN_SRC emacs-lisp
  (use-package moody
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))
#+END_SRC

** Use =minions= to hide all minor modes

I never want to see a minor mode, and manually adding =:diminish= to every
use-package declaration is a hassle. This uses =minions= to hide all the minor
modes in the modeline. Nice!

By default there's a =;-)= after the major mode; that's an adorable default, but
I'd rather skip it.

#+BEGIN_SRC emacs-lisp
   (use-package minions
     :config
     (setq minions-mode-line-lighter ""
           minions-mode-line-delimiters '("" . ""))
     (minions-mode 1))
#+END_SRC

** Disable visual bell

=sensible-defaults= replaces the audible bell with a visual one, but I really
don't even want that (and my Emacs/Mac pair renders it poorly). This disables
the bell altogether.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+BEGIN_SRC emacs-lisp
;  (setq scroll-conservatively 100)
   ;; scroll one line at a time (less "jumpy" than defaults)
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
    ;(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
    (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
    ;(setq scroll-step 1) ;; keyboard scroll one line at a time
#+END_SRC


* General Appearance / Startup
** Font Type

#+BEGIN_SRC emacs-lisp
(set-default-font "Monaco-12")
#+END_SRC

** Display / Color
** Starting the Emacs Server
#+BEGIN_SRC emacs-lisp
(defvar server-socket-dir
  (let ((uid (user-uid)))
    (if (floatp uid)
        (format "/tmp/emacs%1.0f" uid)
      (format "/tmp/emacs%d" uid))))
(require 'server)
(server-ensure-safe-dir server-socket-dir)
(server-start) 

#+END_SRC 
** X11 and Headless
#+BEGIN_SRC emacs-lisp
  (unless window-system
    (when (getenv "DISPLAY")
      ;; Callback for when user cuts
      (defun xsel-cut-function (text &optional push)
        ;; Insert text to temp-buffer, and "send" content to xsel stdin
        (with-temp-buffer
          (insert text)
          ;; I prefer using the "clipboard" selection (the one the
          ;; typically is used by c-c/c-v) before the primary selection
          ;; (that uses mouse-select/middle-button-click)
          (call-process-region (point-min) (point-max) "xsel" nil 0 nil "--clipboard" "--input")))
      ;; Call back for when user pastes
      (defun xsel-paste-function()
        ;; Find out what is current selection by xsel. If it is different
        ;; from the top of the kill-ring (car kill-ring), then return
        ;; it. Else, nil is returned, so whatever is in the top of the
        ;; kill-ring will be used.
        (let ((xsel-output (shell-command-to-string "xsel --clipboard --output")))
          (unless (string= (car kill-ring) xsel-output)
            xsel-output )))
      ;; Attach callbacks to hooks
      (setq interprogram-cut-function 'xsel-cut-function)
      (setq interprogram-paste-function 'xsel-paste-function)
      ;; Idea from
      ;; http://shreevatsa.wordpress.com/2006/10/22/emacs-copypaste-and-x/
      ;; http://www.mail-archive.com/help-gnu-emacs@gnu.org/msg03577.html
      ))
#+END_SRC

** Clipboard
#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-primary t)
  (setq x-select-enable-clipboard t)
  ;; (setq interprogram-paste-function 'x-cut-buffer-or-selection-value)
#+END_SRC

** Key Bindings

#+BEGIN_SRC emacs-lisp

  (defun forward-word-correctly (&optional n)
    "Jump forward a word at a time"
    (interactive "P")
    (search-forward-regexp "[][[()_@#A-Za-z0-9&\\*\\\-\\.\\$]+")
                                          ; [A-Za-z0-9-]+"
    )

  (defun backward-word-correctly (&optional n)
    "Jump backward a word at a time"
    (interactive "P")
    (let (i)
      (search-backward-regexp "\\b[ ]+")
                                          ;    (search-backward-regexp "[A-Za-z0-9_=)]+")
                                          ;    (search-backward-regexp "[A-Za-z0-9_=\-\\)\\(]+")
      )
    )

  (global-set-key "\C-xg" 'goto-line)
  (global-set-key "\C-b" 'backward-kill-word)
  (global-set-key "\C-n" 'kill-word)
  (global-set-key "\C-f" 'backward-word)
  (global-set-key "\M-s" 'search-forward-regexp)
  (global-set-key "\C-g" 'forward-word-correctly)
                                          ; New binding to try out
  (global-set-key "\M-b" 'backward-sexp)
  (global-set-key "\M-n" 'forward-sexp)

  (global-set-key "\C-cc" 'comment-region)
  (global-set-key [(control left)]    'backward-word-correctly)
  (global-set-key [(control right)] 'forward-word-correctly)
#+END_SRC
** ANSI colors
#+BEGIN_SRC emacs-lisp
  (defun display-ansi-colors ()
    (interactive)
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region (point-min) (point-max))))
#+END_SRC
** Disabling electric parentheses
#+BEGIN_SRC emacs-lisp
  (electric-indent-mode -1)
  (add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))
#+END_SRC
** ROS Formatting

   Setting the formatting and give a bind key
#+BEGIN_SRC emacs-lisp
(defun run-ros-clang-format ()
  "Runs clang-format on cpp,h files in catkin_ws/ and reverts buffer."
  (interactive)
  (and
   ;(princ "HERE")
   (string-match "/\\(catkin_ws\\|catkin_.*\\)/.*\\.\\(h\\|cpp\\)$" buffer-file-name)
   ;(princ "THERE")
   (save-some-buffers 'no-confirm)
   (shell-command (concat "clang-format -i -style=file " buffer-file-name))
   ;(princ "OTHER")
   (message (concat "Saved and ran clang-format on " buffer-file-name))
   (revert-buffer t t t)
))

(global-set-key [f7] 'run-ros-clang-format)
#+END_SRC
** Work formatting

#+begin_src emacs-lisp

(load "/usr/share/emacs/site-lisp/clang-format-8/clang-format.el" )
(global-set-key [f7] 'clang-format-region)

(defun run-clang-format ()
  "Runs clang-format on cpp,h files in catkin_ws/ and reverts buffer."
  (interactive)
  (and
   (save-some-buffers 'no-confirm)
   (shell-command (concat "clang-format -i -style=file " buffer-file-name))
   (message (concat "Saved and ran clang-format on " buffer-file-name))
   (revert-buffer t t t)
))

#+end_src
** ROS Compilation

   A cool compilation tool to run catkin builds inside 
#+begin_src emacs-lisp
  ;; Based on https://www.seas.upenn.edu/~chaoliu/2018/03/12/ros-programming-in-emacs/#org8817889
  (require 'ansi-color)
  (defun endless/colorize-compilation ()
    "Colorize from `compilation-filter-start' to `point'."
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region
       compilation-filter-start (point))))

  (add-hook 'compilation-filter-hook #'endless/colorize-compilation)

  (defun ros-catkin-make (dir)
    "Run catkin_make command in DIR."
    (interactive (list (file-name-directory (buffer-file-name))))
    (let* ((default-directory dir)
           (compilation-buffer-name-function (lambda (major-mode-name) "*catkin_make*")))
      (compile "catkin bt --no-status"))
    ;; (switch-to-buffer (get-buffer "*catkin_make*"))
    (switch-to-buffer-other-window (get-buffer-create "*catkin_make*"))
    )

  (defun ros-catkin-make-tests (dir)
    "Run catkin_make command in DIR."
    (interactive (list (file-name-directory (buffer-file-name))))
    (let* ((default-directory dir)
           (compilation-buffer-name-function (lambda (major-mode-name) "*catkin_make*")))
      (compile "catkin run_tests --this --no-status"))
    ;; (switch-to-buffer (get-buffer "*catkin_make*"))
    (switch-to-buffer-other-window (get-buffer-create "*catkin_make*"))
    )

  (global-set-key [f5] 'ros-catkin-make)
#+end_src

** Enable compilations with color

#+BEGIN_SRC emacs-lisp
(require 'ansi-color)
(defun colorize-compilation-buffer ()
  (toggle-read-only)
  (ansi-color-apply-on-region compilation-filter-start (point))
  (toggle-read-only))
(add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+END_SRC
** GDB exit upon receiving Quit
#+BEGIN_SRC emacs-lisp
(defvar all-gud-modes
  '(gud-mode comint-mode gdb-locals-mode gdb-frames-mode  gdb-breakpoints-mode)
  "A list of modes when using gdb")
(defun kill-all-gud-buffers ()
  "Kill all gud buffers including Debugger, Locals, Frames, Breakpoints.
Do this after `q` in Debugger buffer."
  (interactive)
  (save-excursion
        (let ((count 0))
          (dolist (buffer (buffer-list))
                (set-buffer buffer)
                (when (member major-mode all-gud-modes)
                  (setq count (1+ count))
                  (kill-buffer buffer)
                  (delete-other-windows))) ;; fix the remaining two windows issue
          (message "Killed %i buffer(s)." count))))
#+END_SRC
** Ibuffer 
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (require 'ibuf-ext)
  (add-to-list 'ibuffer-never-show-predicates "^\\*")  
#+end_src
** Screenshots
#+begin_src emacs-lisp
(defun my-org-screenshot ()
  "Take a screenshot into a time stamped unique-named file in the
same directory as the org-buffer and insert a link to this file."
  (interactive)
  (setq filename
        (concat
         (make-temp-name
          (concat (buffer-file-name)
                  "_"
                  (format-time-string "%Y%m%d_%H%M%S_")) ) ".png"))
  (call-process "import" nil nil nil filename)
  (insert (concat "[[" filename "]]"))
  (org-display-inline-images))
#+end_src

* Project management

I use a few packages in virtually every programming or writing environment to
manage the project, handle auto-completion, search for terms, and deal with
version control. That's all in here.

** =ag=

Set up =ag= for displaying search results.

#+BEGIN_SRC emacs-lisp
  (use-package ag)
#+END_SRC

** =company=

Use =company-mode= everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package company)
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

Use =M-/= for completion.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete-common)
#+END_SRC

** =dumb-jump=

The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it
doesn't require any additional setup. I've bound its most useful command to
=M-.=.

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :config
    ;; (define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
    (setq dumb-jump-selector 'ivy))
#+END_SRC

** =flycheck=

 #+BEGIN_SRC emacs-lisp
   (use-package flycheck)
 #+END_SRC

** =magit=

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- Use =evil= keybindings with =magit=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- On the command line I'll generally push a new branch with a plain old =git
  push=, which automatically creates a tracking branch on (usually) =origin=.
  Magit, by default, wants me to manually specify an upstream branch. This binds
  =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
  -v=. Convenient!
- I'd like to start in the insert state when writing a commit message.

#+BEGIN_SRC emacs-lisp
  ;; (use-package magit
  ;;   :bind
  ;;   ("C-x C-x g" . magit-status)

  ;;   :config
  ;;   (use-package evil-magit)
  ;;   (use-package with-editor)
  ;;   (setq magit-push-always-verify nil)
  ;;   (setq git-commit-summary-max-length 50)

  ;;   (with-eval-after-load 'magit-remote
  ;;     (magit-define-popup-action 'magit-push-popup ?P
  ;;       'magit-push-implicitly--desc
  ;;       'magit-push-implicitly ?p t))

  ;;   (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

I've been playing around with the newly-released =forge= for managing GitHub PRs
and issues. Seems slick so far.

#+BEGIN_SRC emacs-lisp
  ;; (use-package ghub)
  ;; (use-package forge)
#+END_SRC

** =projectile=

Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds it to the
easier-to-type =C-c v= to useful searches.

Bind =C-p= to fuzzy-finding files in the current project. We also need to
explicitly set that in a few other modes.

I use =ivy= as my completion system.

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projectile-defined project. I use the current directory as a
project root (if I'm not in a "real" project).

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :bind
    ("C-c v" . 'projectile-ag)

    :config
    ;; (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
    ;; (evil-define-key 'motion ag-mode-map (kbd "C-p") 'projectile-find-file)
    ;; (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)

    (setq projectile-completion-system 'ivy)
    (setq projectile-switch-project-action 'projectile-dired)
    (setq projectile-require-project-root nil))
#+END_SRC

** =undo-tree=

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree)
#+END_SRC

* Language Support and Development Environments

** C / C++

*** C Hooks 
#+begin_src emacs-lisp
  (defun my-c-mode-hook ()
    (hs-minor-mode))
  (add-hook 'c++-mode-hook 'my-c-mode-hook)

#+end_src

*** Adds custom C/C++ headers 
#+BEGIN_SRC emacs-lisp
  (defun add-c-function-header( &optional n)
    "Add a default header to a subroutine"
    (interactive "P")
    (setq i 0 )
    (if n 
        (setq count n )
      (setq count (/ PERL_HEADER_LENGTH 2))
      )
    (insert "/*")
    (dotimes (i count)
      (insert "**")
      )
    (insert "\n")
    (insert " * fn::name= ")
    (yank)
    (insert "\n")
    (insert " * fn::desc= \n")
    (insert " * fn::args= \n")
    (insert " * fn::return= \n")
    (insert " * fn::notes=\n")
    (insert " * fn::todo= \n *")
    (dotimes (i (- count 1))
      (insert "**")
      )
    (insert "*/")

    )

  (defun add-c-header( &optional n )
    "Adds the header title information for the C file"
    (interactive "P")
    (let (i count ) 
      (setq count (/ PERL_HEADER_LENGTH 2))
      (insert "/*")
      (dotimes (i count) 
        (insert "**")
        )
      (insert "\n")
      (insert " * source::name= " (buffer-name) "\n")
      (insert " * source::desc=\n")
      (insert " * source::author= " (user-real-login-name) "\n")
      (insert " * source::cvs= $Id$\n")
      (insert " * source::changed= $Date$\n")
      (insert " * source::modusr= $Author$\n")
      (insert " * source::notes=\n")
      (insert " * source::todo=\n *")
      (dotimes (i (- count 1))
        (insert "**")
        )
      (insert "*/")
      )
    )
#+END_SRC

** Perl

   Adds Perl headers
#+BEGIN_SRC emacs-lisp
  (defun add-perl-header( &optional n) 
    "Add a default header line at the start of a script"
    (interactive "P")                     ;need this for args
    (let (i j)
      (setq i 0 )
      ;;  (princ PERL_HEADER_LENGTH)
      (if n 
          (progn
            (setq count n) 
            )
        (setq count PERL_HEADER_LENGTH)
        )
      (insert "#")
      (dotimes (i count)
        (insert "*")
        )
      (let (fname prefix suffix )
        (setq fname (buffer-name))
        (string-match ".*\\.\\(.*\\)" fname)
        (setq suffix (match-string 1 fname))
        (setq prefix (perl-suffix-lookup suffix))
        (insert "\n")
        (insert "# " prefix "::name= " fname "\n")
        (insert "# " prefix "::desc=\n" )
        (insert "# " prefix "::author= " (user-real-login-name) "\n")
        (insert "# " prefix "::cvs= $Id$\n")
        (insert "# " prefix "::changed= $Date$\n")
        (insert "# " prefix "::modusr= $Author$\n")
        (insert "# " prefix "::notes=\n")
        (insert "# " prefix "::todo=\n#")
        (dotimes (i count)
          (insert "*"))
        (insert "\n")
        );let
      (insert "\n\n\n")
      ( _add-perl-divider "LIBRARIES")
      (insert "\n\n")
      ( _add-perl-divider "GLOBAL VARIABLES")
      (insert "\n\n")
      ( _add-perl-divider "CODE")
      (insert "\n\n")
      ( _add-perl-divider "SUBROUTINES")
      );let
    );defun

  (defun perl-suffix-lookup (n)
    "Looks up the tail of a perl script and determines what the header name should be"
                                          ;  (interactive "P")
    (cond ((string= n "pl") "script")
          ((string= n "pm")  "mod" )
          ((string= n "module") "mod" )
          ((string= n "script") "script")
          (t "script"))
    )

  (defun add-perl-sub-header( &optional n)
    "Add a default header to a subroutine"
    (interactive "P")
    (setq i 0 )
    (if n 
        (setq count n )
      (setq count (/ PERL_HEADER_LENGTH 2))
      )
    (insert "#")

    (dotimes (i count)
      (insert "=-")
      )
    (insert "\n")
    (insert "# sub::name= ")
    (yank)
    (insert "\n")
    (insert "# sub::desc= \n")
    (insert "# sub::args= \n")
    (insert "# sub::return= \n")
    (insert "# sub::notes= \n")
    (insert "# sub::todo=\n#")
    (dotimes (i count)
      (insert "=-")
      )
    )

  (defun _add-perl-divider( &optional n char)
    "Add a Label in the middle of a line"
    (interactive "P")
    (setq char nil)
    (if n 
        (let (strln)
          (setq strln (length n))
          (setq i 0 )
          (if n 
              (setq count n )
            (setq count (/ PERL_HEADER_LENGTH 2) )
            )
          (insert "#")
          (let (tmp_length extra) 
            (setq tmp_length (/ (- PERL_HEADER_LENGTH strln 4) 2))
            (setq extra (mod (- PERL_HEADER_LENGTH strln 4) 2))
            (dotimes (i tmp_length)
              (insert "*"))
            (insert (format "  %s  " n ))
            (dotimes (i tmp_length)
              (insert "*"))
            (if (= extra 1)
                (insert "*"))
            )

          )
      nil
      )
    t
    )

  (defun add-perl-top-banner( &optional n )
    "Adds a top banner to the Perl subroutine"
    (interactive "P")
    (let (i count)
      (if n 
          (setq count n )
        (setq count (/ PERL_HEADER_LENGTH 2))
        )
      (insert "#")
      (dotimes (i count)
        (insert "=-")
        )
      (insert "\n")
      )
    )
#+END_SRC 

** Skill
   Formatting functions for Scheme / Skill

#+begin_src emacs-lisp
  (defun skill-suffix-lookup (n)
    "Looks up the tail of a perl script and determines what the header name should be"
                                          ;  (interactive "P")
    (cond ((string= n "ils") "skclass")
          ((string= n "il")  "skill" )
          (t "script"))
    )

  (defun add-skill-divider( &optional n)
    "Add a Skill divider"
    (interactive "P")
    (let (function_name return_type function_args
                        args i tmp)
      (setq a (point-marker))
      (end-of-line)
      (kill-region a (point-marker))
      (setq line (car kill-ring-yank-pointer))
      (_add-skill-divider line)
      )
    )

  (defun _add-skill-divider( &optional n)
    "Add a Label in the middle of a line"
    (interactive "P")
    (if n 
        (let (strln)
          (setq strln (length n))
          (setq i 0 )
          (if n 
              (setq count n )
            (setq count (/ PERL_HEADER_LENGTH 2) )
            )
          (insert ";")
          (let (tmp_length extra) 
            (setq tmp_length (/ (- PERL_HEADER_LENGTH strln 4) 2))
            (setq extra (mod (- PERL_HEADER_LENGTH strln 4) 2))
            (dotimes (i ( / tmp_length 2 ))
              (insert "=~"))
            (insert (format "  %s  " n ))
            (dotimes (i (/ tmp_length 2 ) )
              (insert "=~"))
            (if (= extra 1)
                (insert "="))
                                          ;          (insert (format "\n%d\n" extra))
            )

          )
      nil
      )
    t
    )

  (defun add-skill-class-header( &optional n) 
    "Add a default header line at the Skill script"
    (interactive "P")                     ;need this for args
    (setq i 0 )
    ;;  (princ PERL_HEADER_LENGTH)
    (if n 
        (progn
          (setq count n) 
          )
      (setq count PERL_HEADER_LENGTH)
      )
    (insert ";")
    (dotimes (i ( / count 2 ))
      (insert "=~")
      )
    (let (fname prefix suffix) 
      (setq fname (buffer-name))
      (string-match ".*\\.\\(.*\\)" fname)
      (setq suffix (match-string 1 fname))
      (setq prefix (skill-suffix-lookup suffix))
      (insert "\n")
      (insert "; " prefix "::name= " fname "\n")
      (insert "; " prefix "::desc=\n" )
      (insert "; " prefix "::author= " (user-real-login-name) "\n")
      (insert "; " prefix "::cvs= $Id$\n")
      (insert "; " prefix "::changed= $Date$\n")
      (insert "; " prefix "::modusr= $Author$\n")
      (insert "; " prefix "::notes=\n")
      (insert "; " prefix "::todo=\n;")
      (dotimes (i (/ count 2))
        (insert "=~")
        );dotimes
      (insert "\n" )
      (insert ";\n")
      (insert ";           Copyright (c) 2009, MaxLinear, Inc\n" )
      (insert ";\n;")
      (dotimes (i (/ count 2))
        (insert "=~")
        );dotimes
      );let
    );defun

  (defun add-tex-stuff( &optional n )
    "Adds the default TeX header stuff I like"
    (interactive "P")
    (insert "\\ifdefined\\MASTERDOCUMENT\n")
    (insert "\\else\n")
    (insert "\\documentclass{article}\n")
    (insert "\\input{header}\n")
    (insert "\\begin{document}\n")
    (insert "\\fi\n")
    (insert "\\ifdefined\\MASTERDOCUMENT\n")
    (insert "\\endinput\n")
    (insert "\\else\n" )
    (insert "\\expandafter\\enddocument\n")
    (insert "\\fi\n") 
    )



  (defun add-skill-top-banner( &optional n )
    "Adds a Skill banner to the top of a subroutine"
    (interactive "P")
    (let (i count)
      (if n 
          (setq count n )
        (setq count (/ PERL_HEADER_LENGTH 2))
        )
      (indent-for-tab-command)
      (insert ";")
      (dotimes (i count)
        (insert "=~")
        )
      )
    )

  (defun add-skill-function-header( &optional n )
    "Adds a Skill function header"
    (interactive "P")
    (let (function_name function_type start end indpos indent
                        ) 
      (beginning-of-line)
      (setq start (point-marker (beginning-of-line)))
      (setq indpos (point-marker (forward-sexp)))
      (setq indent (- (marker-position indpos) (marker-position start)))
      (end-of-line)
      (copy-region-as-kill indpos (point-marker))
      (setq line (car kill-ring-yank-pointer))
                                          ;    (posix-string-match "^ *\( *\\([A-z0-9]+\\) *\(" line )
      (posix-string-match "^ *\( *\\([A-z0-9]+\\) *\(?.*$" line )
      (setq function_name ( match-string 1 line))
      (copy-region-as-kill start indpos )
      (setq line (car kill-ring-yank-pointer))
      (posix-string-match "^ *\\([A-z0-9]+\\)$" line )
      (setq function_type (match-string 1 line))
      (goto-char (marker-position start))
      (add-skill-top-banner)
      (insert "\n")
      (skill-fun-header-helper function_type function_name)
                                          ;    (add-skill-top-banner)
      (indent-for-tab-command)
      )
    )

  (defun add-perl-mod-sub-header( &optional n )
    "Adds a complex header title for the Perl subroutine"
    (interactive "P")
    (let (function_name return_type function_args
                        args search listargs counter optionalargs) 
      (setq a (point-marker))
      (setq optionalargs nil)
      (end-of-line)
      (copy-region-as-kill a (point-marker))
      (setq line (car kill-ring-yank-pointer))    
      ( posix-string-match "^ *sub +\\([A-Za-z0-9_]+\\) *(\\([&$@;%*\\ ]*\\))?" line )
      (setq function_name (match-string 1 line))
      (setq function_args (match-string 2 line))
      (setq search (posix-string-match "^\\([\\]?[@&%;$*]\\)\\(.*\\)" function_args))
      (while search
        (setq arg (match-string 1 function_args))
        (setq function_args (match-string 2 function_args))
        (setq search (posix-string-match "^\\([\\]?[&@%;$*]\\)\\(.*\\)" function_args))
        (cond ((if (eq optionalargs nil) t) 
               (cond 
                ((string= arg "\\$")  (push "(SCALAR REF)" listargs ))
                ((string= arg "\\@")  (push "(ARRAY REF)" listargs ))
                ((string= arg "\\%")  (push "(HASH REF)" listargs ))
                ((string= arg "\\*")  (push "(GLOB REF)" listargs ))
                ((string= arg "\\&")  (push "(CODE REF)" listargs ))
                ((string= arg "$" )  (push "(SCALAR)" listargs ))
                ((string= arg "@" )  (push "(ARRAY)" listargs ))
                ((string= arg "%" )  (push "(HASH)" listargs))
                ((string= arg "*" )  (push "(GLOB)" listargs))
                ((string= arg ";" )  (setq optionalargs t))
                )
               )                        ;else...
              ((string= arg "\\$")  (push "(OP:SCALAR REF)" listargs ))
              ((string= arg "\\@")  (push "(OP:ARRAY REF)" listargs ))
              ((string= arg "\\%")  (push "(OP:HASH REF)" listargs ))
              ((string= arg "\\*")  (push "(OP:GLOB REF)" listargs ))
              ((string= arg "\\&")  (push "(OP:CODE REF)" listargs ))
              ((string= arg "$" )  (push "(OP:SCALAR)" listargs ))
              ((string= arg "@" )  (push "(OP:ARRAY)" listargs ))
              ((string= arg "%" )  (push "(OP:HASH)" listargs))
              ((string= arg "*" )  (push "(OP:GLOB)" listargs))
              )
        )
      (goto-char a )
      (add-perl-top-banner)
      (insert (format "# sub::name= %s\n" function_name ) )
      (insert "# sub::desc=\n")
      (insert "# sub::args=\n")
      (setq counter 1)
      (dolist (i (reverse listargs))
        (insert (format "#              %d. %-12s:\n" counter i))
        (setq counter (+ counter 1))
        )
      (insert "# sub::return=\n")
      (insert "# sub::notes=\n")
      (insert "#              None\n")
      (insert "# sub::todo=\n")
      (insert "#              None\n")
      (add-perl-top-banner)
      )
    )

  (defun sw-add-perl-package-header( &optional n )
    "Adds a header title for a Perl Package"
    (interactive "P")
    (let (function_name return_type function_args )



      )
    )

  (defun sw-add-perl-pod-section( &optional n)
    "Adds POD documentation at the end of the file"
    (interactive "P")
    (let ( bufname )
      (insert "__END__\n")
      (insert "\n\n=head1 NAME\n\n")
      (insert (format "%s - INSERT DESCRIPTION\n\n" (buffer-name)))
      (insert "=head1 SYNOPSIS\n\n=over 12\n\n")
      (insert "=item B<fuse_layer.pl>\n\n[][]\n\n")
      (insert "=back\n\n")
      (insert "=head1 OPTIONS AND ARGUMENTS\n\n")
      (insert "=over 8\n\n")
      (insert "=head1 DESCRIPTION\n\n")
      (insert "=head1 SEE ALSO\n\n")
      (insert "=head1 AUTHOR\n\n")
      (insert "Please report bugs to jdamon@maxlinear\n\n")
      )
    ); defun


  (defun sw-add-perl-mod-sub-header( &optional n )
    "Adds a complex header title for the Perl subroutine"
    (interactive "P")
    (let (function_name return_type function_args
                        args search listargs counter optionalargs) 
      (setq a (point-marker))
      (setq optionalargs nil)
      (end-of-line)
      (copy-region-as-kill a (point-marker))
      (setq line (car kill-ring-yank-pointer))    
      ( posix-string-match "^ *sub +\\([A-Za-z0-9_]+\\) *(\\([&$@;%*\\ ]*\\))?" line )
      (setq function_name (match-string 1 line))
      (setq function_args (match-string 2 line))
      (setq search (posix-string-match "^\\([\\]?[@&%;$*]\\)\\(.*\\)" function_args))
      (while search
        (setq arg (match-string 1 function_args))
        (setq function_args (match-string 2 function_args))
        (setq search (posix-string-match "^\\([\\]?[&@%;$*]\\)\\(.*\\)" function_args))
        (cond ((if (eq optionalargs nil) t) 
               (cond 
                ((string= arg "\\$")  (push "(SCALAR REF)" listargs ))
                ((string= arg "\\@")  (push "(ARRAY REF)" listargs ))
                ((string= arg "\\%")  (push "(HASH REF)" listargs ))
                ((string= arg "\\*")  (push "(GLOB REF)" listargs ))
                ((string= arg "\\&")  (push "(CODE REF)" listargs ))
                ((string= arg "$" )  (push "(SCALAR)" listargs ))
                ((string= arg "@" )  (push "(ARRAY)" listargs ))
                ((string= arg "%" )  (push "(HASH)" listargs))
                ((string= arg "*" )  (push "(GLOB)" listargs))
                ((string= arg ";" )  (setq optionalargs t))
                )
               )                        ;else...
              ((string= arg "\\$")  (push "(OP:SCALAR REF)" listargs ))
              ((string= arg "\\@")  (push "(OP:ARRAY REF)" listargs ))
              ((string= arg "\\%")  (push "(OP:HASH REF)" listargs ))
              ((string= arg "\\*")  (push "(OP:GLOB REF)" listargs ))
              ((string= arg "\\&")  (push "(OP:CODE REF)" listargs ))
              ((string= arg "$" )  (push "(OP:SCALAR)" listargs ))
              ((string= arg "@" )  (push "(OP:ARRAY)" listargs ))
              ((string= arg "%" )  (push "(OP:HASH)" listargs))
              ((string= arg "*" )  (push "(OP:GLOB)" listargs))
              )
        )
      (goto-char a )
      (add-perl-top-banner)
      (insert (format "# Name     : %s\n" function_name ) )
      (insert "# Desc     :\n")
      (insert "# Args     :\n")
      (setq counter 1)
      (dolist (i (reverse listargs))
        (insert (format "#              %d. %-12s:\n" counter i))
        (setq counter (+ counter 1))
        )
      (insert "# Returns  :\n")
      (insert "# Throws   :\n")
      (insert "# Notes    :\n")
      (insert "#              none\n")
      (insert "# Todo     :\n")
      (insert "#              none\n")
      (add-perl-top-banner)
      )
    )
;------------------------------------------------------------------------------
;
; fn::name= add-c-mod-function-header
; fn::desc= adds a C function header
; fn::args= 1: optional, that describes number of characers
; fn::desc= 1. Goal is to extract from a given line, the args passed to the
;              function, and the arguments that are returned back to the
;              user itself.
; 
; fn::todos= 1. Paste the elements from the start of the line until the
;               end of the line into a buffer.............................DONE!
;            2. Save the current point, and then insert the text above
;               it........................................................DONE!
;            3. Eventually allow functions to span multiple lines until it
;               reaches the '{' character.................................
;            4. Correctly parse Pointers to functions.....................
;
;            5. Allow correct matching for a term such as follows:
;               const void *key... would be const void *..................DONE!
;            6. Allow pointer to pointer declarations.....................DONE!
;
;            7. Add fix to allow for  function declarations that return
;               pointers, like :  static int *function()..................DONE!
;            8. Add fix for base case, such as void Do_something(void)
;               and just pick up void.....................................
;------------------------------------------------------------------------------
  (defun add-c-mod-function-header( &optional n)
    "Add a default header to a subroutine"
    (interactive "P")
    (let (function_name return_type function_args
                        args i tmp)
      (setq a (point-marker))
      (end-of-line)
      (copy-region-as-kill a (point-marker))
      (setq line (car kill-ring-yank-pointer))    
                                          ;    (string-match "\\(.*\\) +\\([A-Za-z0-9_-\\*]+\\) *( *\\([^)]*\\) *) *{?" line)
      (string-match "\\(.* +\\** *\\)\\([A-Za-z0-9_-]+\\) *( *\\([^)]*\\) *) *{?" line)
      (setq return_type (match-string 1 line))
      (setq function_name (match-string 2 line))
      (setq function_args (match-string 3 line))
      (setq args (split-string function_args "," )) ; Split on the commas...
      (goto-char a)
      (insert "\n")
      (if n 
          (setq count n )
        (setq count (/ PERL_HEADER_LENGTH 2)  )
        )
      (insert "/*")
      (dotimes (i count)
        (insert "**")
        )
      (insert "\n")
      (insert " * fn::name= " function_name "\n" )
      (insert " * fn::desc= \n")
      (insert " * fn::args= \n")
      (setq i 1)
      (dolist (value args)
        (stringp value)
        (posix-string-match "^ *\\([A-Za-z0-9_ ]+\\**\\)\\b\\w+" value)
        (setq tmp (match-string 1 value))
        (insert (format " *%12s%d (%s): \n" " " i tmp) )
        (setq i (+ i 1))
        )
      (insert " * fn::return=\n")
      (insert (format " *%12s%s: \n" " " return_type ))
      (insert " * fn::notes=\n")
      (insert " * fn::todo= \n *")
      (dotimes (i (- count 1))
        (insert "**")
        )
      (insert "*/\n")
      )
    )

#+end_src
** Maxima
#+begin_src emacs-lisp
 (add-to-list 'load-path "/usr/share/emacs/site-lisp/maxima/")
 (autoload 'maxima-mode "maxima" "Maxima mode" t)
 (autoload 'imaxima "imaxima" "Frontend for maxima with Image support" t)
 (autoload 'maxima "maxima" "Maxima interaction" t)
 (autoload 'imath-mode "imath" "Imath mode for math formula input" t)
 (setq imaxima-use-maxima-mode-flag t)
 (add-to-list 'auto-mode-alist '("\\.ma[cx]" . maxima-mode))
#+end_src

** ROS Launch file support 

   These support launch files and test files (the same XML ) that must exist under the 
   test/* directory
#+begin_src emacs-lisp
  (jmd/add-auto-mode
   'xml-mode
   "test\\/.*\\.test$"
   "\\.launch$"
   )
#+end_src

** I associate =shell-script-mode= wth by dot files 
  (jmd/add-auto-mode
   'shell-script-mode
   "\.functions$"
   "\.bashrc$"
   "\.bash_alias$"
   "\.profile"
   )

** Other languages
#+BEGIN_SRC emacs-lisp
  (autoload 'vht-mode         "verilog"      "Vht programming mode" t)
  (autoload 'c++-mode         "cc-mode"      "C++ programming mode" t)
  (autoload 'c-mode           "cc-mode"      "C programming mode" t)
  (autoload 'cvs-update       "pcl-cvs" t)
  (autoload 'cvs-update-other-window "pcl-cvs" t)
  (autoload 'hexl-find-file   "hexl"     "Edit file in hexl-mode." t)
  (autoload 'perl-mode        "perl"     "Perl programming mode" t)
  (autoload 'rdf-mode         "rdf"      "RDF analysis mode" t)
  (autoload 'tm-mode          "tm"       "Time budget mode" t)
  (autoload 'tcl-mode         "tcl"      "Tcl programming mode" t)
  (autoload 'verilog-mode     "verilog"  "Verilog programming mode" t)
  (autoload 'vm               "vm"       "VM mail reader" t)
  (autoload 'spice-mode       "spice"    "Spice Mode"  t)
  (autoload 'spectre-mode "spectre-mode" "Spectre Editing Mode" t)
#+END_SRC

** Linux Kernel Development
#+BEGIN_SRC emacs-lisp
  (defun c-lineup-arglist-tabs-only (ignored)
    "Line up argument lists by tabs, not spaces"
    (let* ((anchor (c-langelem-pos c-syntactic-element))
           (column (c-langelem-2nd-pos c-syntactic-element))
           (offset (- (1+ column) anchor))
           (steps (floor offset c-basic-offset)))
      (* (max steps 1)
         c-basic-offset)))

  (add-hook 'c-mode-common-hook
            (lambda ()
              ;; Add kernel style
              (c-add-style
               "linux-tabs-only"
               '("linux" (c-offsets-alist
                          (arglist-cont-nonempty
                           c-lineup-gcc-asm-reg
                           c-lineup-arglist-tabs-only))))))

  (add-hook 'c-mode-hook
            (lambda ()
              (let ((filename (buffer-file-name)))
                ;; Enable kernel mode for the appropriate files
                (when (and filename
                           (string-match (expand-file-name "~/src/linux-trees")
                                         filename))
                  (setq indent-tabs-mode t)
                  (c-set-style "linux-tabs-only")))))

#+END_SRC

** Custom C Styles
*** Work
#+begin_src emacs-lisp
;; Create my personal style.
(defconst my-c-style
  '((c-tab-always-indent        . t)
    (c-comment-only-line-offset . 4)
    (fill-column  . 109 )
    (c-basic-offset . 4)
    (c-set-offset 'case-label 0)
    (c-hanging-braces-alist     . ((substatement-open after)
                                   (brace-list-open)))
    (c-hanging-colons-alist     . ((member-init-intro before)
                                   (inher-intro)
                                   (case-label after)
                                   (label after)
                                   (access-label after)))
    (c-cleanup-list             . (scope-operator
                                   empty-defun-braces
                                   defun-close-semi))
    (c-offsets-alist            . ((arglist-close . c-lineup-arglist)
                                   (substatement-open . 0)
                                   (case-label        . 4)
                                   (block-open        . 0)
                                   (knr-argdecl-intro . -)))
    (c-echo-syntactic-information-p . t)))
;; ((c-mode . ((fill-column . 109)
;;             (c-basic-offset . 8)
;;             (eval . (c-set-offset 'substatement-open 0))
;;             (eval . (c-set-offset 'statement-case-open 0))
;;             (eval . (c-set-offset 'case-label 0))
;;             (eval . (c-set-offset 'arglist-intro '++))
;;             (eval . (c-set-offset 'arglist-close 0))
;;             (eval . (c-set-offset 'arglist-cont-nonempty '(c-lineup-gcc-asm-reg c-lineup-arglist)))))

;; "My C Programming Style")
(c-add-style "PERSONAL" my-c-style)
#+end_src
*** Local variables

    Use a file called .dir-locals.el. An example is as follows

#+begin_src emacs-lisp
((nil . ((indent-tabs-mode . t)
         (fill-column . 80)
         (mode . auto-fill)))
 (c-mode . ((c-file-style . "BSD")
            (subdirs . nil)))
 ("src/imported"
  . ((nil . ((change-log-default-name
              . "ChangeLog.local"))))))
#+end_src


** Maxima 
#+BEGIN_SRC emacs-lisp
  (setq imaxima-fnt-size "Huge")
#+END_SRC

** Tramp setup
#+BEGIN_SRC emacs-lisp
;   (require 'tramp)
;   (setq tramp-default-method "ssh")
#+END_SRC

** Doxymacs
#+BEGIN_SRC emacs-lisp
  (condition-case nil
      (require 'doxymacs)
    (setq doxymacs-doxygen-style "JavaDoc")
    (add-hook 'c-mode-common-hook'doxymacs-mode)
    (add-hook 'c++-mode-common-hook'doxymacs-mode)
    (error nil)
    )
#+END_SRC

** Spice
** Ruby

I use =chruby= to switch between versions of Ruby. This sets a default version
to use within Emacs (for things like =xmp= or =rspec=).

#+BEGIN_SRC emacs-lisp
  (setq jmd/ruby-version "2.5.3")

  (use-package chruby
    :config
    (chruby jmd/ruby-version))

  (jmd/add-auto-mode
   'ruby-mode
   "\\Gemfile$"
   "\\.rake$"
   "\\.gemspec$"
   "\\Guardfile$"
   "\\Rakefile$"
   "\\Vagrantfile$"
   "\\Vagrantfile.local$")
#+END_SRC

Ruby executables are installed in =~/.gem/ruby/<version>/bin=. This ensures that
that's included in the path. In particular, we want that directory to be
included because it contains the =xmpfilter= executable, which is used below.

#+BEGIN_SRC emacs-lisp
  (jmd/append-to-path (format "~/.gem/ruby/%s/bin" jmd/ruby-version))
#+END_SRC

Running tests from within Emacs is awfully convenient.

#+BEGIN_SRC emacs-lisp
  (use-package rspec-mode)
#+END_SRC

=rcodetools= provides =xmp=, which lets me evaluate a Ruby buffer and display
the results in "magic" (=# =>=) comments.

I disable warnings when running code through =xmp= because I disagree with a few
of them (complaining about private =attr_reader=, especially) and they gunk up
my buffer.
** Yasnippets

#+begin_src emacs-lisp
(use-package yasnippet
  :ensure t 
  :config 
  (use-package yasnippet-snippets
    :ensure t)
  (yas-reload-all))
#+end_src

  Adding a custom snippet for Doxygen

#+begin_src emacs-lisp
(use-package semantic )
;; # -*- mode: snippet -*-
;; # name: dox
;; # key: dox
;; # type: command
;; # --
;; (let ((tag (senator-next-tag)))
;;   (while (or (null tag)
;;              (not (semantic-tag-of-class-p tag 'function)))
;;     (setq tag (senator-next-tag)))
;;   (let* ((name (semantic-tag-name tag))
;;          (attrs (semantic-tag-attributes tag))
;;          (args (plist-get attrs :arguments))
;;          (return-name (plist-get attrs :type))
;;          (idx 1))
;;     (if (listp return-name)
;;       (setq return-name (car return-name)))
;;     (yas/expand-snippet
;;      (format
;;       "/**\n* @brief ${1:%s}\n*%s%s*/"
;;       name
;;       (mapconcat
;;        (lambda (x)
;;          (format "* @param %s ${%d:Description of %s}"
;;                  (car x) (incf idx) (car x)))
;;        args
;;        "\n")
;;       (if (and return-name (not (string-equal "void" return-name)))
;;           (format " * @return ${%d:%s}\n" (incf idx) return-name)
;;         "")))))
#+end_src

* Extra stuff
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook
              (lambda ()
                (push '(">=" . ?≥) prettify-symbols-alist)))
  (lambda (x y)
    (if (>= x y)
        (something)
      (something-else)))
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
; Useful for copying and pasting in emacs in a terminal
; Not sure if this will cause a bug or not
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  (defun now ()
    "Insert string for the current time formatted like '2:34 PM' or 1507121460"
    (interactive)                 ; permit invocation in minibuffer
    (insert (format-time-string "%D %-I:%M %p"))
    )

;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
; Compilation stuff
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  (defun save-all-and-compile ()
    (save-some-buffers 1)
    (compile compile-command))

  (setq compilation-ask-about-save nil)
  (global-set-key [f5] 'compile)

  (setq TeX-PDF-from-DVI "Dvips") 
  ;; (add-to-list 'load-path "/home/jdamon/.emacs.d/share/emacs/site-lisp")
  ;; (add-to-list 'load-path "/usr/share/emacs24/site-lisp/")
  ;; (add-to-list 'load-path "/usr/share/emacs24/site-lisp/auto-complete");
  ;; (condition-case nil
  ;; (require 'auto-complete-config)
  ;; (add-to-list 'ac-dictionary-directories "/usr/share/emacs23/site-lisp//ac-dict")
  ;; (ac-config-default)
  ;; (error nil)
  ;; )
  ;; (add-to-list 'load-path "/home/jdamon/.emacs.d/neotree" )
  ;; (require 'neotree)
  ;; (global-set-key [f8] 'neotree-toggle)
                                          ;check system name
  (add-to-list 'load-path "/home/jdamon/.emacs.d/lisp")
  (add-to-list 'load-path "/home/jdamon/.emacs.d/xcscope")
  (add-to-list 'load-path "/usr/share/emacs23/site-lisp/")

  (condition-case nil
      (load "auctex.el" nil t t)
    (load "preview-latex.el" nil t t)
    (error nil)
    )

  (condition-case nil
      (load "ggtags.elc" nil t t )
    (add-hook 'c-mode-common-hook
              (lambda ()
                (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                  (ggtags-mode 1))))
    (error nil)
    )
  ;; (load "smart-compile.el" nil t t )
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
; Auto compilation
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ;; (load "mode-compile.el" nil t t )
  (defun mode-compile-quiet ()
    (interactive)
    (flet ((read-string (&rest args) ""))
      (mode-compile)))

  ;; Bury the compilation buffer when compilation is finished and successful.
  (add-to-list 'compilation-finish-functions
               (lambda (buffer msg)
                 (when 
                     (bury-buffer buffer)
                   (replace-buffer-in-windows buffer))))

  ;; C-c C-% will set a buffer local hook to use mode-compile after saving
  (global-set-key '[(ctrl c) (ctrl %)]
                  (lambda () 
                    (interactive)
                    (if (member 'mode-compile-quiet after-save-hook)
                        (progn
                          (setq after-save-hook 
                                (remove 'mode-compile-quiet after-save-hook))
                          (message "No longer compiling after saving."))
                      (progn
                        (add-to-list 'after-save-hook 'mode-compile-quiet)
                        (message "Compiling after saving.")))))

  ;; Prevent compilation buffer from showing up
  ;; (defadvice compile (around compile/save-window-excursion first () activate)
  ;;   (save-window-excursion ad-do-it))

  ;; Bury the compilation buffer when compilation is finished and successful.
  (add-to-list 'compilation-finish-functions
               (lambda (buffer msg)
                 (when 
                     (bury-buffer buffer)
                   (replace-buffer-in-windows buffer))))

  (setq compilation-scroll-output 'first-error)

  ;; (require  'xcscope )
  (define-key global-map [(control f4)]  'cscope-pop-mark)
  (define-key global-map [(control f5)]  'cscope-find-this-text-string)
  (define-key global-map [(control f6)]  'cscope-find-this-symbol)
  (define-key global-map [(control f7)]  'cscope-find-functions-calling-this-function)
  (define-key global-map [(control f8)]  'cscope-find-called-functions)
  (define-key global-map [(control f9)]  'cscope-prev-symbol)
  (define-key global-map [(control f10)] 'cscope-next-symbol)
         ;;; XEmacs backwards compatibility file
  (line-number-mode t)
                                          ;(put 'my-operator 'scheme-indent-function 3)
                                          ; Stuff for setting up key bindings...

  (condition-case nil
      (require 'auto-complete-config)
    (error nil)
    )    

  (defun describe-face-at-point ()
    "Return face used at point."
    (interactive)
    (hyper-describe-face (get-char-property (point) 'face)))

  (defun jump-down (&optional n )
    "Jump downwards by n secions of 8 lines"
    (interactive "P")
    (let (i count)
      (if n
          (progn 
            (setq count n)
            )
        (setq count 1)
        )
      (dotimes ( i count)
        (forward-line (* 8 (+ i 1)))
        )
      )
    )

  (defun jump-up (&optional n )
    "Jump upwards by n sections of 8 lines"
    (interactive "P")
    (let (i count)
      (if n
          (progn 
            (setq count n)
            )
        (setq count 1)
        )
      (dotimes ( i count)
        (forward-line (* -8 (+ i 1)))
        )
      )
    )

  (defun charlie-settings( &optional n )
    "Setup the charlie settings"
    (interactive "P")
    (c-set-offset 'statement-block-intro 4)
    (c-set-offset 'defun-block-intro 4)
    )



  (setq-default indent-tabs-mode nil)     ; Turn off default tabs
  (setq inhibit-startup-message t)        ; Turn off start up message
  (setq inhibit-default-init t)           ; Turn off default init and messages
  (setq home-dir (getenv "HOME"))
  (defvar PERL_HEADER_LENGTH 76
    "Controls the length of headers")

  (global-set-key [(control button2)] 'x-copy-primary-selection)
  (global-set-key [(button4)] 'scroll-down)
  (global-set-key [(button5)] 'scroll-up)
  (global-set-key "\M-[a" 'jump-up)
  (global-set-key "\M-[b" 'jump-down)
  (global-set-key "\C-b" 'backward-kill-word)
  (global-set-key "\C-n" 'kill-word)
  (global-set-key "\M-?" 'help-command)
  (global-set-key "\M-\C-s" 'shell)
  (global-set-key "\M-\C-l" 'toggle-buffers-in-window)
  (global-set-key "\C-xg" 'goto-line)
  (global-set-key "\C-c\C-c" 'comment-region)
  ;; (global-set-key (kbd "C-x C-b") 'ibuffer)
  ;; (require 'ibuf-ext)
  ;; (add-to-list 'ibuffer-never-show-predicates "^\\*")
  ;; (add-to-list 'ibuffer-never-show-regexps "^\\*")


  (global-set-key [(control right)] 'forward-word)
  (global-set-key [(control left)]  'backward-word )
  (define-key global-map [(control bracket)] 'backward-paragraph)
  (defalias 'scroll-ahead 'scroll-up)
  (defalias 'scroll-behind 'scroll-down)
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
; 
; Defined functions for customization 
;
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  (defun scroll-n-lines-ahead ( &optional n )
    "Scroll Ahead N lines( 1 by default )."
    (interactive "P")
    (scroll-ahead (prefix-numeric-value n)))
  (defun scroll-n-lines-behind (&optional n)
    "Scroll Behind N lines( 1 by default )."
    (interactive "P")
    (scroll-behind (prefix-numeric-value n)))
  (defun lets-test-it (&optional n )
    "Examining the characteristics of parameters"
    (interactive)                         ;no args
    (princ n)
    )

  (require 'font-lock)
  (defvar null-device "/dev/null")
  (setq auto-mode-alist (append (list (cons "\\.scs$" 'spectre-mode)
                                      (cons "\\.inp$" 'spectre-mode))
                                auto-mode-alist))

  (setq perl-indent-level 4)
  (setq cperl-indent-level 4)
  (setq cperl-font-lock t)
  (setq cperl-syntaxify-by-font-lock t)
  ;(cperl-set-style "BSD")   ; Need to find a way to specify the style with a variable...

  (add-hook 'cperl-hook-mode 'outline-minor-mode)

  (line-number-mode t)
  (display-time )
  (defun refill-mode (&optional arg)
    "Refill Minor Mode"
    (interactive "P")
    (setq refill-mode
          (if (null arg)
              (not refill-mode)
            (> (prefix-numeric-value arg) 0))

          )
    (make-local-hook 'after-change-functions)
    (if refill-mode
        (add-hook 'after-change-functions 'refill nil t)
      (remove-hook 'after-change-functions 'refill t)
      )
    )

  (defun writeroom ()
    "Switches to a WriteRoom-like fullscreen style"
    (interactive) 
    (when (featurep 'aquamacs)
      ;; switch to white on black
      ;; (color-theme-initialize)
      ;; (color-theme-clarity)
      ;; (color-theme-scintilla)
      ;; switch to Garamond 36pt
      (aquamacs-autoface-mode 0)
      (set-frame-font "-apple-garamond-medium-r-normal--36-360-72-72-m-360-iso10646-1")
      ;; switch to fullscreen mode
      (aquamacs-toggle-full-frame)))

  (defun iconify-or-deiconify-frame-fullscreen-even ()
    (interactive)
    (if (eq (cdr (assq 'visibility (frame-parameters))) t)
        (progn
          (if (frame-parameter nil 'fullscreen) 
              (aquamacs-toggle-full-frame))     
                                          ;       (switch-to-buffer "*scratch*") 
          (iconify-frame))
      (make-frame-visible))) 
  (define-key global-map "\C-z" #'iconify-or-deiconify-frame-fullscreen-even)

  (defun skill-fun-header-helper( name function_name )
    "Extra helper function that uses the name and extra to setup headers"
    (indent-for-tab-command)
    (insert (format "; %s::name=     : %s\n" name function_name ) )
    (indent-for-tab-command)
    (insert (format "; %s::desc=     :\n" name ))
    (indent-for-tab-command)
    (insert (format "; %s::args=     :\n" name ))
    (setq counter 1)
    (indent-for-tab-command)
    (insert (format "; %s::returns=  :\n" name ))
    (indent-for-tab-command)
    (insert (format "; %s::throws=   :\n" name ))
    (indent-for-tab-command)
    (insert (format "; %s::notes=    :\n" name ))
    (indent-for-tab-command)
    (insert (format ";              none\n"))
    (indent-for-tab-command)
    (insert (format "; %s::todo     :\n" name ))
    (indent-for-tab-command)
    (insert (format ";              none\n"))
    (add-skill-top-banner)
    (insert "\n")
    )

  (add-hook 'c-mode-common-hook 'linum-mode)
  (add-hook 'c-mode-common-hook 'outline-minor-mode ) 
  (add-hook 'python-mode-hook 'linum-mode)

  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
                                          ;(princ edit-tab-stops-map)
  (defun bisque-background()
    "Switches to bisque background for better vision"
    (interactive) 
    (set-background-color "bisque")
    (custom-set-faces
     '(hl-line ((t (:background "tan1"))))
     '(font-lock-string-face ((t (:foreground "medium orchid"))))
     )
    )

  (if (display-graphic-p) 
      () 
    (load-theme 'wheatgrass)
    (xterm-mouse-mode)
    )


  (defun my-add-semantic-to-autocomplete()
    (add-to-list 'ac-sources 'ac-source-semantic)
    )

  (add-hook 'c-mode-common-hook 'my-add-semantic-to-autocomplete)
  (electric-indent-mode -1)


(defun window-toggle-split-direction ()
  "Switch window split from horizontally to vertically, or vice versa.

i.e. change right window to bottom, or change bottom window to right."
  (interactive)
  (require 'windmove)
  (let ((done))
    (dolist (dirs '((right . down) (down . right)))
      (unless done
        (let* ((win (selected-window))
               (nextdir (car dirs))
               (neighbour-dir (cdr dirs))
               (next-win (windmove-find-other-window nextdir win))
               (neighbour1 (windmove-find-other-window neighbour-dir win))
               (neighbour2 (if next-win (with-selected-window next-win
                                          (windmove-find-other-window neighbour-dir next-win)))))
          ;;(message "win: %s\nnext-win: %s\nneighbour1: %s\nneighbour2:%s" win next-win neighbour1 neighbour2)
          (setq done (and (eq neighbour1 neighbour2)
                          (not (eq (minibuffer-window) next-win))))
          (if done
              (let* ((other-buf (window-buffer next-win)))
                (delete-window next-win)
                (if (eq nextdir 'right)
                    (split-window-vertically)
                  (split-window-horizontally))
                (set-window-buffer (windmove-find-other-window neighbour-dir) other-buf))))))))

  ;; (defun toggle-window-split ()
  ;;   (interactive)
  ;;   (if (= (count-windows) 2)
  ;;       (let* ((this-win-buffer (window-buffer))
  ;;              (next-win-buffer (window-buffer (next-window)))
  ;;              (this-win-edges (window-edges (selected-window)))
  ;;              (next-win-edges (window-edges (next-window)))
  ;;              (this-win-2nd (not (and (<= (car this-win-edges)
  ;;                                          (car next-win-edges))
  ;;                                      (<= (cadr this-win-edges)
  ;;                                          (cadr next-win-edges)))))
  ;;              (splitter
  ;;               (if (= (car this-win-edges)
  ;;                      (car (window-edges (next-window))))
  ;;                   'split-window-horizontally
  ;;                 'split-window-vertically)))
  ;;         (delete-other-windows)
  ;;         (let ((first-win (selected-window)))
  ;;           (funcall splitter)
  ;;           (if this-win-2nd (other-window 1))
  ;;           (set-window-buffer (selected-window) this-win-buffer)
  ;;           (set-window-buffer (next-window) next-win-buffer)
  ;;           (select-window first-win)
  ;;           (if this-win-2nd (other-window 1))))))))

  (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
  (setq org-display-inline-images t) 
  (setq org-redisplay-inline-images t) 
  (setq org-startup-with-inline-images "inlineimages")


                                          ;  (require 'calendar)



  (setq epa-file-cache-passphrase-for-symmetric-encryption t )
  (setq org-deadline-warning-days 0)
  (use-package flycheck-ledger :after ledger-mode )

  (setq org-return-follows-link t )
  (require 'org-jira)
  (setq jiralib-url "https://automodality.atlassian.net")

  (defconst org-jira-progress-issue-flow
  '(("To Do" . "In Progress")
    ("In Progress" . "Ready to Test")
    ("Ready To Test" . "Done")
    ("Done" . "In Progress")))


#+END_SRC 

* Publishing and task management with Org-mode
** Org Setup
*** Loading Org
#+begin_src emacs-lisp
  (use-package org)
#+end_src

*** Org Directory Setup
#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/Projects/org")
  (add-hook 'org-mode-hook 'outline-minor-mode)
#+END_SRC

*** Scaling Preview Latex 
#+BEGIN_SRC emacs-lisp
  (set-default 'preview-scale-function 1.9 )
#+END_SRC

*** Don't indent by 2, instead use native indentation
#+begin_src emacs-lisp
(setq org-src-tab-acts-natively t )
(setq org-src-fontify-natively t )
(setq org-src-preserve-indentation t)
(setq org-src-strip-leading-and-trailing-blank-lines t)
#+end_src

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :init
  (add-hook 'org-mode-hook 'org-bullets-mode))
(setq org-bullets-bullet-list '("◉" "○" "✸"  "☯" "✿" "✜" "☯" "◆" "☯" "▶" ))

#+END_SRC

** Enforce TODO dependendices
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src

** Nice looking Bullet symbols


I borrowed this from Harry Schwartz as I too "like seeing a little
downward-pointing arrow instead of the usual ellipsis (=...=) that org
displays when there's stuff under a header."
#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC 

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

Hiding leading stars
#+BEGIN_SRC emacs-lisp
  (setq org-hide-leading-stars t)
#+END_SRC

** CDLaTeX mode
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src

** Org images


   Allows us to scale the image sizes
#+begin_src emacs-lisp
(setq org-image-actual-width nil)
#+end_src

** Displaying LateX and other graphics inline

   A hold over
#+begin_src emacs-lisp
  ;(add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+end_src

** Extra Org stuff
** Org Inbox, Index and Archive location 
 #+BEGIN_SRC emacs-lisp
   (defun org-file-path (filename)
     "Return the absolute address of an org file, given its relative name."
     (concat (file-name-as-directory org-directory) filename))

   (setq org-inbox-file "~/Dropbox/inbox.org")
   (setq org-index-file (org-file-path "index.org"))
   (setq org-archive-location
         (concat (org-file-path "archive.org") "::"))
#+END_SRC

** Archiving Org mode entries
#+BEGIN_SRC emacs-lisp
(defun jmd/personal-mark-done-and-archive ()
  "Mark the state of an org-mode item as DONE and archive it."
  (interactive)
  (org-todo 'done)
  (org-archive-subtree)
  (setq foo (org-get-tags-string)))

(defun jmd/mark-work-done-and-archive ()
  "Mark the state of an org-mode item as DONE and archive it."
  (interactive)
  (org-todo 'done)
  (org-toggle-tag "work" )
  (org-archive-subtree)
  ;; (setq foo (org-get-tags-string))
  )

(defun my/org-checkbox-todo ()
  "Switch header TODO state to DONE when all checkboxes are ticked, to TODO otherwise"
  (let ((todo-state (org-get-todo-state)) beg end)
    (unless (not todo-state)
      (save-excursion
        (org-back-to-heading t)
        (setq beg (point))
        (end-of-line)
        (setq end (point))
        (goto-char beg)
        (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                               end t)
            (if (match-end 1)
                (if (equal (match-string 1) "100%")
                    (unless (string-equal todo-state "DONE")
                      (org-todo 'done))
                  (unless (string-equal todo-state "TODO")
                    (org-todo 'todo)))
              (if (and (> (match-end 2) (match-beginning 2))
                       (equal (match-string 2) (match-string 3)))
                  (unless (string-equal todo-state "DONE")
                    (org-todo 'done))
                (unless (string-equal todo-state "TODO")
                  (org-todo 'todo)))))))))

(add-hook 'org-checkbox-statistics-hook 'my/org-checkbox-todo)
(define-key org-mode-map (kbd "C-c C-x C-s") 'jmd/mark-done-and-archive)

#+END_SRC

** Enforce 

** Exporting code
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src

** Org Drill
#+BEGIN_SRC emacs-lisp
; (eval-after-load "org"
;   '(progn
;     (add-to-list 'load-path "/home/jdamon/.emacs.d/elpa/org-drill")
;     (require 'org-drill)))
#+END_SRC
** Rest of ORG

#+BEGIN_SRC emacs-lisp

   (defun org-journal-find-location ()
     ;; Open today's journal, but specify a non-nil prefix argument in order to
     ;; inhibit inserting the heading; org-capture will insert the heading.
     (org-journal-new-entry t)
     ;; Position point on the journal's top-level heading so that org-capture
     ;; will add the new entry as a child entry.
     (goto-char (point-min)))

   (setq org-src-fontify-natively t )
   (setq org-src-tab-acts-natively t )
   (setq org-src-window-setup 'current-window )
   (setq org-clock-persist 'history)
   (setq org-log-done t)
   (setq org-log-into-drawer t)
   (setq org-tags-column 80)

   ;; ("j" "Journal" entry (function org-journal-find-location)
   ;;  "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")
   ;; ("j" "Journal" entry (file+olp+datetree "~/Projects/org/journal.org"
   ;;                                         "* %?\nEntered on %U\n"))
   ;                                                   ("j" "Journal" entry (file+olp+datetree "~/Projects/org/journal.org")
   ;                                                   "* %?\nEnterered on %U\n   %i\n   %a")
   ; @todo FIX this journal to use the org-journal
   ;       but that requires fixing the function org-journal-find-location which is annoying 
   ;       because it pops up two editor windows, one from the function itself and another
   ;       from the org-capture.
   (setq org-capture-templates
         '(("t" "Todo" entry (file+headline "~/Projects/org/todo.org" "Tasks")
            "* TODO %?\n%i\n   %a")
           ("j" "Journal" entry (file+olp+datetree "~/Projects/org/journal.org")
                                                  "* %? %^G\nEntered on %U\n")
           ("W" "Work Journal" entry (file+olp+datetree "~/Projects/org/workjournal.org")
            "* %?\n   %i\n   %a\nEnterered on %U\n")
           ("f" "Finished book"
            table-line (file "~/Documents/notes/books-read.org")
            "| %^{Title} | %^{Author} | %u |")
           ("s" "Subscribe to an RSS feed"
            plain
            (file "~/Documents/rss/urls")
            "%^{Feed URL} \"~%^{Feed name}\"")
           ))

   (setq org-journal-file-format "%Y%m%d.org")
   (setq org-hide-emphasis-markers t )

   (org-babel-do-load-languages
    'org-babel-load-languages
    '((python . t)
      (ledger . t)
      (latex . t)
      (ditaa . t)
      (shell . t)
      (dot . t)
      (ruby . t)
      (scala . t)
      (kotlin . t)
      (maxima . t )
      ))
   ;;

   (defun org-journal-save-entry-and-exit()
     "Simple convenience function.
              Saves the buffer of the current day's entry and kills the window
              Similar to org-capture like behavior"
     (interactive)
     (save-buffer)
     (kill-buffer-and-window))

   ;;----------------------------------------------------------------------
   ;; OS specific

   (cond
    ((string-equal system-type "windows-nt") ; Microsoft Windows

     (progn
       (setq-default ispell-program-name "C:/bin/Aspell/bin/aspell.exe") 
       (setq org-ditaa-jar-path "c:/bin/ditaa/ditaa.jar")
       )
     )
    ((string-equal system-type "gnu/linux") ; Linux
     (progn
       (setq x-select-enable-clipboard t)
       (setq org-ditaa-jar-path "/usr/bin/ditaa")
       )
     )
    )


                                           ;(ledger . t)
                                           ; Use this to save my location in files when i reopen them
   (save-place-mode t)

   (org-clock-persistence-insinuate)
   (defun org-archive-done-tasks ()
     (interactive)
     (org-map-entries
      (lambda ()
        (org-archive-subtree)
        (setq org-map-continue-from (outline-previous-heading)))
      "/DONE" 'tree))
   (global-set-key "\C-cl" 'org-store-link)
   (global-set-key "\C-ca" 'org-agenda)
   (global-set-key "\C-cc" 'org-capture)
   (global-set-key "\C-cb" 'org-switchb)



   (defun org-agenda-skip-deadline-if-not-thisweek ()
     "If this function returns nil, the current match should not be skipped.
               Otherwise, the function must return a position from where the search
               should be continued."
     (ignore-errors
       (let ((subtree-end (save-excursion (org-end-of-subtree t)))
             (deadline-day
              (time-to-days
               (org-time-string-to-time
                (org-entry-get nil "DEADLINE"))))
             (now (time-to-days (current-time))))
         (and deadline-day
              (not (= deadline-day now))
              subtree-end))))
   (setq org-agenda-start-with-log-mode '(closed clock state))
   (setq org-agenda-log-mode-items '(closed clock state))
   (setq org-agenda-custom-commands
         '(("c" "Simple agenda view"
            ((agenda "")
             (alltodo "")))
           ("h" "Work Things"
            ((agenda "" ((org-agenda-ndays 1)
                         (org-agenda-sorting-strategy
                          (quote ((agenda time-up priority-down tag-up))))
                         (org-deadline-warning-days 0)))
             ))
           ("W" "Weely review"
            ((agenda ""
                     ((org-agenda-span 'week)
                      (org-agenda-start-on-weekday 0)
                      (org-agenda-start-with-log-mode '(closed clock state))
                      ;; (org-agenda-skip-function
                      ;;  '(org-agenda-skip-entry-if 'nottodo 'done))
                      )))
            )
           ))

   (defun jmd-org-tasks-closed-in-month (&optional month year match-string)
     "Produces an org agenda tags view list of the tasks completed 
        in the specified month and year. Month parameter expects a number 
        from 1 to 12. Year parameter expects a four digit number. Defaults 
        to the current month when arguments are not provided. Additional search
        criteria can be provided via the optional match-string argument "
     (interactive)
     (let* ((today (calendar-current-date))
            (for-month (or month (calendar-extract-month today)))
            (for-year  (or year  (calendar-extract-year today))))
       (org-tags-view nil 
                      (concat
                       match-string
                       (format "+CLOSED>=\"[%d-%02d-01]\"" 
                               for-year for-month)
                       (format "+CLOSED<=\"[%d-%02d-%02d]\"" 
                               for-year for-month 
                               (calendar-last-day-of-month for-month for-year))))))

   (defun jmd-org-tasks-query-for-month (&optional month year)
     (interactive)
     (let* ((today (calendar-current-date))
            (for-month (or month (calendar-extract-month today)))
            (for-year  (or year  (calendar-extract-year today))))
       (concat
        (format "+CLOSED>=\"[%d-%02d-01]\"" for-year for-month)
        (format "+CLOSED<=\"[%d-%02d-%02d]\"" for-year for-month  (calendar-last-day-of-month for-month for-year)))
       ))

   (defun jmd-work-tasks-last-month ()
     "Produces an org agenda tags view list of all the tasks completed
          last month with for work "
     (interactive)
     (let* ((today (calendar-current-date))
            (for-month (calendar-extract-month today))
            (for-year  (calendar-extract-year today)))
       (calendar-increment-month for-month for-year -1)
       (org-tags-view nil (concat "TODO=\"DONE\"" 
                                  (jmd-org-tasks-query-for-month for-month for-year) 
                                  "|ARCHIVE_ITAGS=\"work\""
                                  (jmd-org-tasks-query-for-month for-month for-year)))))

   ;; (define-key org-journal-mode-map (kbd "C-x C-s") 'org-journal-save-entry-and-exit)
 #+END_SRC
** Org Download
#+BEGIN_SRC emacs-lisp
  (require 'org-download)

  ;; Drag-and-drop to `dired`
  (add-hook 'dired-mode-hook 'org-download-enable)
  (add-hook 'org-mode 'org-download-enable)
  (setq-default org-download-image-dir "~/Projects/org/Pictures/")
#+END_SRC
** Org Exporting 
#+begin_src emacs-lisp
(setq org-export-coding-system 'utf-8)
#+end_src
** Org quizzing
#+BEGIN_SRC emacs-lisp
;  (setq org-drill-add-random-noise-to-intervals-p t )
;  (setq org-drill-learn-fraction 0.1)
#+END_SRC
** Org Journaling

#+begin_src emacs-lisp
  (use-package org-journal
   :bind (("C-c t" . journal-file-today)
          ("C-c y" . journal-file-yesterday))
   :custom
   (org-journal-dir "~/Projects/org/journal/")
   (org-journal-file-format "%Y%m%d")
   (org-journal-date-format "%e %b %Y (%A)")
   (org-journal-time-format "")
   :preface

   (defun get-journal-file-yesterday ()
     "Gets filename for yesterday's journal entry."
     (let* ((yesterday (time-subtract (current-time) (days-to-time 1)))
            (daily-name (format-time-string "%Y%m%d" yesterday)))
       (expand-file-name (concat org-journal-dir daily-name))))

   (defalias 'journal-file-today 'org-journal-new-entry)

   (defun journal-file-yesterday ()
     "Creates and load a file based on yesterday's date."
     (interactive)
     (find-file (get-journal-file-yesterday))))
#+end_src

#+RESULTS:
: journal-file-yesterday
** Org Roam
#+begin_src emacs-lisp
  (use-package org-roam
        :hook 
        (after-init . org-roam-mode)
        :custom
        (org-roam-directory "~/Projects/org/")
        :bind (:map org-roam-mode-map
                (("C-c n l" . org-roam)
                 ("C-c n f" . org-roam-find-file)
                 ("C-c n b" . org-roam-switch-to-buffer)
                 ("C-c n g" . org-roam-graph-show))
                :map org-mode-map
                (("C-c n i" . org-roam-insert))))
#+end_src
** Deft
   
#+begin_src emacs-lisp
  (use-package deft
    :bind ("<f8>" . deft)
    :commands (deft)
    :config (setq deft-directory "~/Projects/org"
                  deft-extensions '("md" "org")))
  (global-set-key (kbd "C-c d") 'deft)
  (setq deft-extensions '("org"))
  (setq deft-text-mode 'org-mode) 
  (setq deft-use-filename-as-title t )
  (setq deft-recursive t)
#+end_src 

* Email 
** Outgoing Email server 
   Send mail using postfix
#+begin_src emacs-lisp
(setq send-mail-function 'sendmail-send-it)
(setq message-send-mail-function 'message-send-mail-with-sendmail)
#+end_src
** Mu4E 
#+BEGIN_SRC emacs-lisp
  (setq mu4e-maildir (expand-file-name "~/Maildir"))
  (setq mu4e-get-mail-command "true")
  (setq mu4e-change-filenames-when-moving t)
  (setq smtpmail-queue-mail nil  ;; start in normal mode
        smtpmail-queue-dir   "~/Maildir/queue/cur")
  ;; (use-package evil-mu4e)
  ;; (require 'evil-mu4e)
#+END_SRC
** Mu4E Alerts

#+begin_src emacs-lisp
(use-package mu4e-alert
  :ensure t
  :after mu4e
  :init
  ;; (setq mu4e-alert-interesting-mail-query
  ;;   (concat
  ;;    "flag:unread maildir:/Exchange/INBOX "
  ;;    "OR "
  ;;    "flag:unread maildir:/Gmail/INBOX"
  ;;    ))
  (mu4e-alert-enable-mode-line-display)
  (defun jmd-refresh-mu4e-alert-mode-line ()
    (interactive)
    (mu4e~proc-kill)
    (mu4e-alert-enable-mode-line-display)
    )
  (run-with-timer 0 60 'jmd-refresh-mu4e-alert-mode-line)
  )



#+end_src
** Allow MU4E to save links to emails

#+begin_src emacs-lisp
(require 'org-mu4e)
#+end_src


